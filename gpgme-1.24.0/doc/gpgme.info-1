This is gpgme.info, produced by makeinfo version 6.8 from gpgme.texi.

Copyright © 2002–2008, 2010, 2012–2018 g10 Code GmbH.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU General Public License as
     published by the Free Software Foundation; either version 3 of the
     License, or (at your option) any later version.  The text of the
     license can be found in the section entitled “Copying”.

   This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.
INFO-DIR-SECTION GNU Libraries
START-INFO-DIR-ENTRY
* GPGME: (gpgme).          Adding support for cryptography to your program.
END-INFO-DIR-ENTRY

   This file documents the GPGME library.

   This is Edition 1.24.0-beta635, last updated 29 October 2024, of ‘The
‘GnuPG Made Easy’ Reference Manual’, for Version 1.24.0-beta635.

   Copyright © 2002–2008, 2010, 2012–2018 g10 Code GmbH.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU General Public License as
     published by the Free Software Foundation; either version 3 of the
     License, or (at your option) any later version.  The text of the
     license can be found in the section entitled “Copying”.

   This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.


File: gpgme.info,  Node: Top,  Next: Introduction,  Up: (dir)

Main Menu
*********

This is Edition 1.24.0-beta635, last updated 29 October 2024, of ‘The
‘GnuPG Made Easy’ Reference Manual’, for Version 1.24.0-beta635 of the
GPGME library.

* Menu:

* Introduction::                  How to use this manual.
* Preparation::                   What you should do before using the library.
* Protocols and Engines::         Supported crypto protocols.
* Algorithms::                    Supported algorithms.
* Error Handling::                Error numbers and their meanings.
* Exchanging Data::               Passing data to and from GPGME.
* Contexts::                      Handling GPGME contexts.

Appendices

* UI Server Protocol::            The GnuPG UI Server Protocol.
* Debugging::                     How to solve problems.
* Deprecated Functions::          Documentation of deprecated functions.

* Library Copying::               The GNU Lesser General Public License says
                                  how you can copy and share ‘GnuPG Made Easy’.
* Copying::                       The GNU General Public License says how you
                                  can copy and share this manual.

Indices

* Concept Index::                 Index of concepts and programs.
* Function and Data Index::       Index of functions, variables and data types.

 — The Detailed Node Listing —

Introduction

* Getting Started::               Purpose of the manual, and how to use it.
* Features::                      Reasons to install and use GPGME.
* Overview::                      Basic architecture of the GPGME library.

Preparation

* Header::                        What header file you need to include.
* Building the Source::           Compiler options to be used.
* Largefile Support (LFS)::       How to use GPGME with LFS.
* Using Automake::                Compiler options to be used the easy way.
* Using Libtool::                 Avoiding compiler options entirely.
* Library Version Check::         Getting and verifying the library version.
* Signal Handling::               How GPGME affects signal handling.
* Multi-Threading::               How GPGME can be used in an MT environment.

Protocols and Engines

* Engine Version Check::          Verifying the engine version.
* Engine Information::            Obtaining more information about the engines.
* Engine Configuration::          Changing the engine configuration.
* OpenPGP::                       Support for the OpenPGP protocol.
* Cryptographic Message Syntax::  Support for the CMS.

Algorithms

* Public Key Algorithms::         A list of all public key algorithms.
* Hash Algorithms::               A list of all hash algorithms.

Error Handling

* Error Values::                  The error value and what it means.
* Error Codes::                   A list of important error codes.
* Error Sources::                 A list of important error sources.
* Error Strings::                 How to get a descriptive string from a value.

Exchanging Data

* Creating Data Buffers::         Creating new data buffers.
* Destroying Data Buffers::       Releasing data buffers.
* Manipulating Data Buffers::     Operations on data buffers.

Creating Data Buffers

* Memory Based Data Buffers::     Creating memory based data buffers.
* File Based Data Buffers::       Creating file based data buffers.
* Callback Based Data Buffers::   Creating callback based data buffers.

Manipulating Data Buffers

* Data Buffer I/O Operations::    I/O operations on data buffers.
* Data Buffer Meta-Data::         Meta-data manipulation of data buffers.
* Data Buffer Convenience::       Convenience function for data buffers.

Contexts

* Creating Contexts::             Creating new GPGME contexts.
* Destroying Contexts::           Releasing GPGME contexts.
* Result Management::             Managing the result of crypto operations.
* Context Attributes::            Setting properties of a context.
* Key Management::                Managing keys with GPGME.
* Crypto Operations::             Using a context for cryptography.
* Miscellaneous::                 Miscellaneous operations.
* Run Control::                   Controlling how operations are run.

Context Attributes

* Protocol Selection::            Selecting the protocol used by a context.
* Crypto Engine::                 Configuring the crypto engine.
* Setting the Sender::            How to tell the engine the sender.
* ASCII Armor::                   Requesting ASCII armored output.
* Text Mode::                     Choosing canonical text mode.
* Offline Mode::                  Choosing offline mode.
* Included Certificates::         Including a number of certificates.
* Key Listing Mode::              Selecting key listing mode.
* Passphrase Callback::           Getting the passphrase from the user.
* Progress Meter Callback::       Being informed about the progress.
* Status Message Callback::       Status messages received from gpg.
* Locale::                        Setting the locale of a context.

Key Management

* Key objects::                   Description of the key structures.
* Listing Keys::                  Browsing the list of available keys.
* Information About Keys::        Requesting detailed information about keys.
* Manipulating Keys::             Operations on keys.
* Generating Keys::               Creating new key pairs.
* Signing Keys::                  Adding key signatures to public keys.
* Exporting Keys::                Retrieving key data from the key ring.
* Importing Keys::                Adding keys to the key ring.
* Deleting Keys::                 Removing keys from the key ring.
* Changing Passphrases::          Change the passphrase of a key.
* Changing TOFU Data::            Changing data pertaining to TOFU.
* Advanced Key Editing::          Advanced key edit operation.

Crypto Operations

* Decrypt::                       Decrypting a ciphertext.
* Verify::                        Verifying a signature.
* Decrypt and Verify::            Decrypting a signed ciphertext.
* Sign::                          Creating a signature.
* Encrypt::                       Encrypting a plaintext.

Sign

* Selecting Signers::             How to choose the keys to sign with.
* Creating a Signature::          How to create a signature.
* Signature Notation Data::       How to add notation data to a signature.

Encrypt

* Encrypting a Plaintext::        How to encrypt a plaintext.

Miscellaneous

* Running other Programs::        Running other Programs.
* Using the Assuan protocol::     Using the Assuan protocol.
* Checking for updates::          How to check for software updates.

Run Control

* Waiting For Completion::        Waiting until an operation is completed.
* Using External Event Loops::    Advanced control over what happens when.
* Cancellation::                  How to end pending operations prematurely.

Using External Event Loops

* I/O Callback Interface::        How I/O callbacks are registered.
* Registering I/O Callbacks::     How to use I/O callbacks for a context.
* I/O Callback Example::          An example how to use I/O callbacks.
* I/O Callback Example GTK+::     How to integrate GPGME in GTK+.
* I/O Callback Example GDK::      How to integrate GPGME in GDK.
* I/O Callback Example Qt::       How to integrate GPGME in Qt.



File: gpgme.info,  Node: Introduction,  Next: Preparation,  Prev: Top,  Up: Top

1 Introduction
**************

‘GnuPG Made Easy’ (GPGME) is a C language library that allows to add
support for cryptography to a program.  It is designed to make access to
public key crypto engines like GnuPG or GpgSM easier for applications.
GPGME provides a high-level crypto API for encryption, decryption,
signing, signature verification and key management.

   GPGME uses GnuPG and GpgSM as its backends to support OpenPGP and the
Cryptographic Message Syntax (CMS).

* Menu:

* Getting Started::               Purpose of the manual, and how to use it.
* Features::                      Reasons to install and use GPGME.
* Overview::                      Basic architecture of the GPGME library.


File: gpgme.info,  Node: Getting Started,  Next: Features,  Up: Introduction

1.1 Getting Started
===================

This manual documents the GPGME library programming interface.  All
functions and data types provided by the library are explained.

   The reader is assumed to possess basic knowledge about cryptography
in general, and public key cryptography in particular.  The underlying
cryptographic engines that are used by the library are not explained,
but where necessary, special features or requirements by an engine are
mentioned as far as they are relevant to GPGME or its users.

   This manual can be used in several ways.  If read from the beginning
to the end, it gives a good introduction into the library and how it can
be used in an application.  Forward references are included where
necessary.  Later on, the manual can be used as a reference manual to
get just the information needed about any particular interface of the
library.  Experienced programmers might want to start looking at the
examples at the end of the manual, and then only read up those parts of
the interface which are unclear.

   The documentation for the language bindings is currently not included
in this manual.  Those languages bindings follow the general programming
model of GPGME but may provide some extra high level abstraction on top
of the GPGME style API. For now please see the README files in the
‘lang/’ directory of the source distribution.


File: gpgme.info,  Node: Features,  Next: Overview,  Prev: Getting Started,  Up: Introduction

1.2 Features
============

GPGME has a couple of advantages over other libraries doing a similar
job, and over implementing support for GnuPG or other crypto engines
into your application directly.

it’s free software
     Anybody can use, modify, and redistribute it under the terms of the
     GNU Lesser General Public License (*note Library Copying::).

it’s flexible
     GPGME provides transparent support for several cryptographic
     protocols by different engines.  Currently, GPGME supports the
     OpenPGP protocol using GnuPG as the backend, and the Cryptographic
     Message Syntax using GpgSM as the backend.

it’s easy
     GPGME hides the differences between the protocols and engines from
     the programmer behind an easy-to-use interface.  This way the
     programmer can focus on the other parts of the program, and still
     integrate strong cryptography in his application.  Once support for
     GPGME has been added to a program, it is easy to add support for
     other crypto protocols once GPGME backends provide them.

it’s language friendly
     GPGME comes with languages bindings for several common programming
     languages: Common Lisp, C++, Python 2, and Python 3.


File: gpgme.info,  Node: Overview,  Prev: Features,  Up: Introduction

1.3 Overview
============

GPGME provides a data abstraction that is used to pass data to the
crypto engine, and receive returned data from it.  Data can be read from
memory or from files, but it can also be provided by a callback
function.

   The actual cryptographic operations are always set within a context.
A context provides configuration parameters that define the behaviour of
all operations performed within it.  Only one operation per context is
allowed at any time, but when one operation is finished, you can run the
next operation in the same context.  There can be more than one context,
and all can run different operations at the same time.

   Furthermore, GPGME has rich key management facilities including
listing keys, querying their attributes, generating, importing,
exporting and deleting keys, and acquiring information about the trust
path.

   With some precautions, GPGME can be used in a multi-threaded
environment, although it is not completely thread safe and thus needs
the support of the application.


File: gpgme.info,  Node: Preparation,  Next: Protocols and Engines,  Prev: Introduction,  Up: Top

2 Preparation
*************

To use GPGME, you have to perform some changes to your sources and the
build system.  The necessary changes are small and explained in the
following sections.  At the end of this chapter, it is described how the
library is initialized, and how the requirements of the library are
verified.

* Menu:

* Header::                        What header file you need to include.
* Building the Source::           Compiler options to be used.
* Largefile Support (LFS)::       How to use GPGME with LFS.
* Using Automake::                Compiler options to be used the easy way.
* Using Libtool::                 Avoiding compiler options entirely.
* Library Version Check::         Getting and verifying the library version.
* Signal Handling::               How GPGME affects signal handling.
* Multi-Threading::               How GPGME can be used in an MT environment.


File: gpgme.info,  Node: Header,  Next: Building the Source,  Up: Preparation

2.1 Header
==========

All interfaces (data types and functions) of the library are defined in
the header file ‘gpgme.h’.  You must include this in all programs using
the library, either directly or through some other header file, like
this:

     #include <gpgme.h>

   The name space of GPGME is ‘gpgme_*’ for function names and data
types and ‘GPGME_*’ for other symbols.  Symbols internal to GPGME take
the form ‘_gpgme_*’ and ‘_GPGME_*’.

   Because GPGME makes use of the GPG Error library, using GPGME will
also use the ‘GPG_ERR_*’ name space directly, and the ‘gpg_err*’,
‘gpg_str*’, and ‘gpgrt_*’ name space indirectly.


File: gpgme.info,  Node: Building the Source,  Next: Largefile Support (LFS),  Prev: Header,  Up: Preparation

2.2 Building the Source
=======================

If you want to compile a source file including the ‘gpgme.h’ header
file, you must make sure that the compiler can find it in the directory
hierarchy.  This is accomplished by adding the path to the directory in
which the header file is located to the compilers include file search
path (via the ‘-I’ option).

   However, the path to the include file is determined at the time the
source is configured.  To solve this problem, gpgme ships with
‘gpgme.pc’ file, that knows about the path to the include file and other
configuration options.  The command, ‘pkg-config’, can be used to handle
information with ‘gpgme.pc’ file.  In an environment which doesn’t have
‘pkg-config’ (like the one in early stage of OS bootstrap), for
Automake, you can use ‘gpgme.m4’ which invokes ‘gpgrt-config’ with
‘gpgme.pc’.  (In the past, gpgme used to ship with a small helper
program ‘gpgme-config’.  This functionality of ‘gpgme-config’ is
replaced by ‘pkg-config’ with ‘gpgme.pc’ file.)

   The options that need to be added to the compiler invocation at
compile time are output by the ‘--cflags’ option to ‘pkg-config gpgme’.
The following example shows how it can be used at the command line:

     gcc -c foo.c `pkg-config --cflags gpgme`

   Adding the output of ‘pkg-config --cflags gpgme’ to the compiler
command line will ensure that the compiler can find the GPGME header
file.

   A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search path
(via the ‘-L’ option).  For this, the option ‘--libs’ to ‘pkg-config
gpgme’ can be used.  For convenience, this option also outputs all other
options that are required to link the program with GPGME (in particular,
the ‘-lgpgme’ option).  The example shows how to link ‘foo.o’ with the
GPGME library to a program ‘foo’.

     gcc -o foo foo.o `pkg-config --libs gpgme`

   Of course you can also combine both examples to a single command by
specifying both options to ‘pkg-config gpgme’:

     gcc -o foo foo.c `pkg-config --cflags --libs gpgme`


File: gpgme.info,  Node: Largefile Support (LFS),  Next: Using Automake,  Prev: Building the Source,  Up: Preparation

2.3 Largefile Support (LFS)
===========================

GPGME is compiled with largefile support by default, if it is available
on the system.  This means that GPGME supports files larger than two
gigabyte in size, if the underlying operating system can.  On some
systems, largefile support is already the default.  On such systems,
nothing special is required.  However, some systems provide only support
for files up to two gigabyte in size by default.  Support for larger
file sizes has to be specifically enabled.

   To make a difficult situation even more complex, such systems provide
two different types of largefile support.  You can either get all
relevant functions replaced with alternatives that are largefile
capable, or you can get new functions and data types for largefile
support added.  Those new functions have the same name as their
smallfile counterparts, but with a suffix of 64.

   An example: The data type ‘off_t’ is 32 bit wide on GNU/Linux PC
systems.  To address offsets in large files, you can either enable
largefile support add-on.  Then a new data type ‘off64_t’ is provided,
which is 64 bit wide.  Or you can replace the existing ‘off_t’ data type
with its 64 bit wide counterpart.  All occurrences of ‘off_t’ are then
automagically replaced.

   As if matters were not complex enough, there are also two different
types of file descriptors in such systems.  This is important because if
file descriptors are exchanged between programs that use a different
maximum file size, certain errors must be produced on some file
descriptors to prevent subtle overflow bugs from occurring.

   As you can see, supporting two different maximum file sizes at the
same time is not at all an easy task.  However, the maximum file size
does matter for GPGME, because some data types it uses in its interfaces
are affected by that.  For example, the ‘off_t’ data type is used in the
‘gpgme_data_seek’ function, to match its POSIX counterpart.  This
affects the call-frame of the function, and thus the ABI of the library.
Furthermore, file descriptors can be exchanged between GPGME and the
application.

   For you as the user of the library, this means that your program must
be compiled in the same file size mode as the library.  Luckily, there
is absolutely no valid reason for new programs to not enable largefile
support by default and just use that.  The compatibility modes (small
file sizes or dual mode) can be considered an historic artefact, only
useful to allow for a transitional period.

   On POSIX platforms GPGME is compiled using largefile support by
default.  This means that your application must do the same, at least as
far as it is relevant for using the ‘gpgme.h’ header file.  All types in
this header files refer to their largefile counterparts, if they are
different from any default types on the system.

   On 32 and 64 bit Windows platforms ‘off_t’ is declared as 32 bit
signed integer.  There is no specific support for LFS in the C library.
The recommendation from Microsoft is to use the native interface
(‘CreateFile’ et al.)  for large files.  Released binary versions of
GPGME (libgpgme-11.dll) have always been build with a 32 bit ‘off_t’.
To avoid an ABI break we stick to this convention for 32 bit Windows by
using ‘long’ there.  GPGME versions for 64 bit Windows have never been
released and thus we are able to use ‘int64_t’ instead of ‘off_t’ there.
For easier migration the typedef ‘gpgme_off_t’ has been defined.  The
reason we cannot use ‘off_t’ directly is that some toolchains (e.g.,
mingw64) introduce a POSIX compatible hack for ‘off_t’.  Some widely
used toolkits make use of this hack and in turn GPGME would need to use
it also.  However, this would introduce an ABI break and existing
software making use of libgpgme might suffer from a severe break.  Thus
with version 1.4.2 we redefined all functions using ‘off_t’ to use
‘gpgme_off_t’ which is defined as explained above.  This way we keep the
ABI well defined and independent of any toolchain hacks.  The bottom
line is that LFS support in GPGME is only available on 64 bit versions
of Windows.

   On POSIX platforms you can enable largefile support, if it is
different from the default on the system the application is compiled on,
by using the Autoconf macro ‘AC_SYS_LARGEFILE’.  If you do this, then
you don’t need to worry about anything else: It will just work.  In this
case you might also want to use ‘AC_FUNC_FSEEKO’ to take advantage of
some new interfaces, and ‘AC_TYPE_OFF_T’ (just in case).

   If you do not use Autoconf, you can define the preprocessor symbol
‘_FILE_OFFSET_BITS’ to 64 _before_ including any header files, for
example by specifying the option ‘-D_FILE_OFFSET_BITS=64’ on the
compiler command line.  You will also want to define the preprocessor
symbol ‘LARGEFILE_SOURCE’ to 1 in this case, to take advantage of some
new interfaces.

   If you do not want to do either of the above, you probably know
enough about the issue to invent your own solution.  Just keep in mind
that the GPGME header file expects that largefile support is enabled, if
it is available.  In particular, we do not support dual mode
(‘_LARGEFILE64_SOURCE’).


File: gpgme.info,  Node: Using Automake,  Next: Using Libtool,  Prev: Largefile Support (LFS),  Up: Preparation

2.4 Using Automake
==================

You can simply use ‘PKG_CHECK_MODULES’ macro with ‘pkg-config’:
     PKG_CHECK_MODULES([GPGME], [gpgme >= 1.23.1])

   Alternatively, instead of using ‘pkg-config’, for building on an
environment with no pkg-config, GPGME provides an extension to Automake
that does all the work for you.  Please note that it is required to have
gpgrt-config from libgpg-error installed in this case.

 -- Macro: AM_PATH_GPGME ([MINIMUM-VERSION], [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     Check whether GPGME (at least version MINIMUM-VERSION, if given)
     exists on the host system.  If it is found, execute
     ACTION-IF-FOUND, otherwise do ACTION-IF-NOT-FOUND, if given.

     This macro locates for ‘gpgme.pc’, with cross-compile support.

     Additionally, the function defines ‘GPGME_CFLAGS’ to the flags
     needed for compilation of the program to find the ‘gpgme.h’ header
     file, and ‘GPGME_LIBS’ to the linker flags needed to link the
     program to the GPGME library.

     ‘AM_PATH_GPGME_PTHREAD’ was provided to check for the version of
     GPGME with the native pthread implementation, and it defined
     ‘GPGME_PTHREAD_CFLAGS’ and ‘GPGME_PTHREAD_LIBS’.  Since version
     1.8.0 this is no longer necessary, as GPGME itself is thread safe.
     Please use plain ‘AM_PATH_GPGME’ instead, with ‘GPGME_CFLAGS’ and
     ‘GPGME_LDFLAGS’.

   You can use the defined Autoconf variables like this in your
‘Makefile.am’:

     AM_CPPFLAGS = $(GPGME_CFLAGS)
     LDADD = $(GPGME_LIBS)


File: gpgme.info,  Node: Using Libtool,  Next: Library Version Check,  Prev: Using Automake,  Up: Preparation

2.5 Using Libtool
=================

The easiest way is to just use GNU Libtool.  If you use libtool, and
link to ‘libgpgme.la’, everything will be done automatically by Libtool.


File: gpgme.info,  Node: Library Version Check,  Next: Signal Handling,  Prev: Using Libtool,  Up: Preparation

2.6 Library Version Check
=========================

 -- Function: const char * gpgme_check_version
          (const char *REQUIRED_VERSION)
     The function ‘gpgme_check_version’ has four purposes.  It can be
     used to retrieve the version number of the library.  In addition it
     can verify that the version number is higher than a certain
     required version number.  In either case, the function initializes
     some sub-systems, and for this reason alone it must be invoked
     early in your program, before you make use of the other functions
     in GPGME.  The last purpose is to run selftests.

     As a side effect for W32 based systems, the socket layer will get
     initialized.

     If REQUIRED_VERSION is ‘NULL’, the function returns a pointer to a
     statically allocated string containing the version number of the
     library.

     If REQUIRED_VERSION is not ‘NULL’, it should point to a string
     containing a version number, and the function checks that the
     version of the library is at least as high as the version number
     provided.  In this case, the function returns a pointer to a
     statically allocated string containing the version number of the
     library.  If REQUIRED_VERSION is not a valid version number, or if
     the version requirement is not met, the function returns ‘NULL’.

     If you use a version of a library that is backwards compatible with
     older releases, but contains additional interfaces which your
     program uses, this function provides a run-time check if the
     necessary features are provided by the installed version of the
     library.

     If a selftest fails, the function may still succeed.  Selftest
     errors are returned later when invoking ‘gpgme_new’ or
     ‘gpgme-data_new’, so that a detailed error code can be returned
     (historically, ‘gpgme_check_version’ does not return a detailed
     error code).

 -- Function: int gpgme_set_global_flag (const char *NAME,
          const char *VALUE)

     SINCE: 1.4.0

     On some systems it is not easy to set environment variables and
     thus hard to use GPGME’s internal trace facility for debugging.
     This function has been introduced as an alternative way to enable
     debugging and for a couple of other rarely used tweaks.  It is
     important to assure that only one thread accesses GPGME functions
     between a call to this function and after the return from the call
     to ‘gpgme_check_version’.

     All currently supported features require that this function is
     called as early as possible — even before ‘gpgme_check_version’.
     The features are identified by the following values for NAME:

     ‘debug’
          To enable debugging use the string “debug” for NAME and VALUE
          identical to the value used with the environment variable
          ‘GPGME_DEBUG’.

     ‘disable-gpgconf’
          Using this feature with any VALUE disables the detection of
          the gpgconf program and thus forces GPGME to fallback into the
          simple OpenPGP only mode.  It may be used to force the use of
          GnuPG-1 on systems which have both GPG versions installed.
          Note that in general the use of ‘gpgme_set_engine_info’ is a
          better way to select a specific engine version.

     ‘gpgconf-name’
     ‘gpg-name’
          Set the name of the gpgconf respective gpg binary.  The
          defaults are ‘GNU/GnuPG/gpgconf’ and ‘GNU/GnuPG/gpg’.  Under
          Unix the leading directory part is ignored.  Under Windows the
          leading directory part is used as the default installation
          directory; the ‘.exe’ suffix is added by GPGME. Use forward
          slashed even under Windows.

     ‘require-gnupg’
          Set the minimum version of the required GnuPG engine.  If that
          version is not met, GPGME fails early instead of trying to use
          the existent version.  The given version must be a string with
          major, minor, and micro number.  Example: "2.1.0".

     ‘inst-type’
          The installation type is used to prefer a certain GnuPG
          installation.  The value is interpreted as an integer: A value
          of 0 is ignored, a value of 1 indicates an installation scheme
          as used by Gpg4win, a value of 2 indicates an installation
          scheme as used by GnuPG Desktop on Windows.  All other values
          are reserved.

     ‘w32-inst-dir’
          On Windows GPGME needs to know its installation directory to
          find its spawn helper.  This is in general no problem because
          a DLL has this information.  Some applications however link
          statically to GPGME and thus GPGME can only figure out the
          installation directory of this application which may be wrong
          in certain cases.  By supplying an installation directory as
          value to this flag, GPGME will assume that that directory is
          the installation directory.  This flag has no effect on
          non-Windows platforms.

     This function returns ‘0’ on success.  In contrast to other
     functions the non-zero return value on failure does not convey any
     error code.  For setting “debug” the only possible error cause is
     an out of memory condition; which would exhibit itself later
     anyway.  Thus the return value may be ignored.

   After initializing GPGME, you should set the locale information to
the locale required for your output terminal.  This locale information
is needed for example for the curses and Gtk pinentry.  Here is an
example of a complete initialization:

     #include <locale.h>
     #include <gpgme.h>

     void
     init_gpgme (void)
     {
       /* Initialize the locale environment.  */
       setlocale (LC_ALL, "");
       gpgme_check_version (NULL);
       gpgme_set_locale (NULL, LC_CTYPE, setlocale (LC_CTYPE, NULL));
     #ifdef LC_MESSAGES
       gpgme_set_locale (NULL, LC_MESSAGES, setlocale (LC_MESSAGES, NULL));
     #endif
     }

   Note that you are highly recommended to initialize the locale
settings like this.  GPGME can not do this for you because it would not
be thread safe.  The conditional on LC_MESSAGES is only necessary for
portability to W32 systems.


File: gpgme.info,  Node: Signal Handling,  Next: Multi-Threading,  Prev: Library Version Check,  Up: Preparation

2.7 Signal Handling
===================

The GPGME library communicates with child processes (the crypto
engines).  If a child process dies unexpectedly, for example due to a
bug, or system problem, a ‘SIGPIPE’ signal will be delivered to the
application.  The default action is to abort the program.  To protect
against this, ‘gpgme_check_version’ sets the ‘SIGPIPE’ signal action to
‘SIG_IGN’, which means that the signal will be ignored.

   GPGME will only do that if the signal action for ‘SIGPIPE’ is
‘SIG_DEF’ at the time ‘gpgme_check_version’ is called.  If it is
something different, ‘GPGME’ will take no action.

   This means that if your application does not install any signal
handler for ‘SIGPIPE’, you don’t need to take any precautions.  If you
do install a signal handler for ‘SIGPIPE’, you must be prepared to
handle any ‘SIGPIPE’ events that occur due to GPGME writing to a defunct
pipe.  Furthermore, if your application is multi-threaded, and you
install a signal action for ‘SIGPIPE’, you must make sure you do this
either before ‘gpgme_check_version’ is called or afterwards.


File: gpgme.info,  Node: Multi-Threading,  Prev: Signal Handling,  Up: Preparation

2.8 Multi-Threading
===================

The GPGME library is mostly thread-safe, and can be used in a
multi-threaded environment but there are some requirements for
multi-threaded use:

   • The function ‘gpgme_check_version’ must be called before any other
     function in the library, because it initializes the thread support
     subsystem in GPGME.  To achieve this in multi-threaded programs,
     you must synchronize the memory with respect to other threads that
     also want to use GPGME.  For this, it is sufficient to call
     ‘gpgme_check_version’ before creating the other threads using
     GPGME(1).

   • Any ‘gpgme_data_t’ and ‘gpgme_ctx_t’ object must only be accessed
     by one thread at a time.  If multiple threads want to deal with the
     same object, the caller has to make sure that operations on that
     object are fully synchronized.

   • Only one thread at any time is allowed to call ‘gpgme_wait’.  If
     multiple threads call this function, the caller must make sure that
     all invocations are fully synchronized.  It is safe to start
     asynchronous operations while a thread is running in gpgme_wait.

   • The function ‘gpgme_strerror’ is not thread safe.  You have to use
     ‘gpgme_strerror_r’ instead.

   ---------- Footnotes ----------

   (1) At least this is true for POSIX threads, as ‘pthread_create’ is a
function that synchronizes memory with respects to other threads.  There
are many functions which have this property, a complete list can be
found in POSIX, IEEE Std 1003.1-2003, Base Definitions, Issue 6, in the
definition of the term “Memory Synchronization”.  For other thread
packages other, more relaxed or more strict rules may apply.


File: gpgme.info,  Node: Protocols and Engines,  Next: Algorithms,  Prev: Preparation,  Up: Top

3 Protocols and Engines
***********************

GPGME supports several cryptographic protocols, however, it does not
implement them.  Rather it uses backends (also called engines) which
implement the protocol.  GPGME uses inter-process communication to pass
data back and forth between the application and the backend, but the
details of the communication protocol and invocation of the backend is
completely hidden by the interface.  All complexity is handled by GPGME.
Where an exchange of information between the application and the backend
is necessary, GPGME provides the necessary callback function hooks and
further interfaces.

 -- Data type: enum gpgme_protocol_t
     The ‘gpgme_protocol_t’ type specifies the set of possible protocol
     values that are supported by GPGME.  The following protocols are
     supported:

     ‘GPGME_PROTOCOL_OpenPGP’
     ‘GPGME_PROTOCOL_OPENPGP’
          This specifies the OpenPGP protocol.

     ‘GPGME_PROTOCOL_CMS’
          This specifies the Cryptographic Message Syntax.

     ‘GPGME_PROTOCOL_GPGCONF’
          Under development.  Please ask on <gnupg-devel@gnupg.org> for
          help.

     ‘GPGME_PROTOCOL_ASSUAN’
          SINCE: 1.2.0

          This specifies the raw Assuan protocol.

     ‘GPGME_PROTOCOL_G13’
          SINCE: 1.3.0

          Under development.  Please ask on <gnupg-devel@gnupg.org> for
          help.

     ‘GPGME_PROTOCOL_UISERVER’
          Under development.  Please ask on <gnupg-devel@gnupg.org> for
          help.

     ‘GPGME_PROTOCOL_SPAWN’
          SINCE: 1.5.0

          Special protocol for use with ‘gpgme_op_spawn’.

     ‘GPGME_PROTOCOL_UNKNOWN’
          Reserved for future extension.  You may use this to indicate
          that the used protocol is not known to the application.
          Currently, GPGME does not accept this value in any operation,
          though, except for ‘gpgme_get_protocol_name’.

 -- Function: const char * gpgme_get_protocol_name
          (gpgme_protocol_t PROTOCOL)
     The function ‘gpgme_get_protocol_name’ returns a statically
     allocated string describing the protocol PROTOCOL, or ‘NULL’ if the
     protocol number is not valid.

* Menu:

* Engine Version Check::          Verifying the engine version.
* Engine Information::            Obtaining more information about the engines.
* Engine Configuration::          Changing the engine configuration.
* OpenPGP::                       Support for the OpenPGP protocol.
* Cryptographic Message Syntax::  Support for the CMS.
* Assuan::                        Support for the raw Assuan protocol.


File: gpgme.info,  Node: Engine Version Check,  Next: Engine Information,  Up: Protocols and Engines

3.1 Engine Version Check
========================

 -- Function: const char * gpgme_get_dirinfo (cons char *WHAT)
     SINCE: 1.5.0

     The function ‘gpgme_get_dirinfo’ returns a statically allocated
     string with the value associated to WHAT.  The returned values are
     the defaults and won’t change even after ‘gpgme_set_engine_info’
     has been used to configure a different engine.  ‘NULL’ is returned
     if no value is available.  Commonly supported values for WHAT are:

     ‘homedir’
          Return the default home directory.

     ‘sysconfdir’
          Return the name of the system configuration directory

     ‘bindir’
          Return the name of the directory with GnuPG program files.

     ‘libdir’
          Return the name of the directory with GnuPG related library
          files.

     ‘libexecdir’
          Return the name of the directory with GnuPG helper program
          files.

     ‘datadir’
          Return the name of the directory with GnuPG shared data.

     ‘localedir’
          Return the name of the directory with GnuPG locale data.

     ‘socketdir’
          Return the name of the directory with the following sockets.

     ‘agent-socket’
          Return the name of the socket to connect to the gpg-agent.

     ‘agent-ssh-socket’
          Return the name of the socket to connect to the ssh-agent
          component of gpg-agent.

     ‘dirmngr-socket’
          Return the name of the socket to connect to the dirmngr.

     ‘uiserver-socket’
          Return the name of the socket to connect to the user interface
          server.

     ‘gpgconf-name’
          Return the file name of the engine configuration tool.

     ‘gpg-name’
          Return the file name of the OpenPGP engine.

     ‘gpgsm-name’
          Return the file name of the CMS engine.

     ‘g13-name’
          Return the name of the file container encryption engine.

     ‘keyboxd-name’
          Return the name of the key database daemon.

     ‘agent-name’
          Return the name of gpg-agent.

     ‘scdaemon-name’
          Return the name of the smart card daemon.

     ‘dirmngr-name’
          Return the name of dirmngr.

     ‘pinentry-name’
          Return the name of the pinentry program.

     ‘gpg-wks-client-name’
          Return the name of the Web Key Service tool.

     ‘gpgtar-name’
          Return the name of the gpgtar program.

 -- Function: gpgme_error_t gpgme_engine_check_version
          (gpgme_protocol_t PROTOCOL)
     The function ‘gpgme_engine_check_version’ verifies that the engine
     implementing the protocol PROTOCOL is installed in the expected
     path and meets the version requirement of GPGME.

     This function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     engine is available and ‘GPG_ERR_INV_ENGINE’ if it is not.


File: gpgme.info,  Node: Engine Information,  Next: Engine Configuration,  Prev: Engine Version Check,  Up: Protocols and Engines

3.2 Engine Information
======================

 -- Data type: gpgme_engine_info_t
     The ‘gpgme_engine_info_t’ type specifies a pointer to a structure
     describing a crypto engine.  The structure contains the following
     elements:

     ‘gpgme_engine_info_t next’
          This is a pointer to the next engine info structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘gpgme_protocol_t protocol’
          This is the protocol for which the crypto engine is used.  You
          can convert this to a string with ‘gpgme_get_protocol_name’
          for printing.

     ‘const char *file_name’
          This is a string holding the file name of the executable of
          the crypto engine.  Currently, it is never ‘NULL’, but using
          ‘NULL’ is reserved for future use, so always check before you
          use it.

     ‘const char *home_dir’
          This is a string holding the directory name of the crypto
          engine’s configuration directory.  If it is ‘NULL’, then the
          default directory is used.  See ‘gpgme_get_dirinfo’ on how to
          get the default directory.

     ‘const char *version’
          This is a string containing the version number of the crypto
          engine.  It might be ‘NULL’ if the version number can not be
          determined, for example because the executable doesn’t exist
          or is invalid.

     ‘const char *req_version’
          This is a string containing the minimum required version
          number of the crypto engine for GPGME to work correctly.  This
          is the version number that ‘gpgme_engine_check_version’
          verifies against.  Currently, it is never ‘NULL’, but using
          ‘NULL’ is reserved for future use, so always check before you
          use it.

 -- Function: gpgme_error_t gpgme_get_engine_info
          (gpgme_engine_info_t *INFO)
     The function ‘gpgme_get_engine_info’ returns a linked list of
     engine info structures in INFO.  Each info structure describes the
     defaults of one configured backend.

     The memory for the info structures is allocated the first time this
     function is invoked, and must not be freed by the caller.

     This function returns the error code ‘GPG_ERR_NO_ERROR’ if
     successful, and a system error if the memory could not be
     allocated.

   Here is an example how you can provide more diagnostics if you
receive an error message which indicates that the crypto engine is
invalid.

     gpgme_ctx_t ctx;
     gpgme_error_t err;

     [...]

     if (gpgme_err_code (err) == GPG_ERR_INV_ENGINE)
       {
         gpgme_engine_info_t info;
         err = gpgme_get_engine_info (&info);
         if (!err)
           {
             while (info && info->protocol != gpgme_get_protocol (ctx))
               info = info->next;
             if (!info)
               fprintf (stderr, "GPGME compiled without support for protocol %s",
                        gpgme_get_protocol_name (info->protocol));
             else if (info->file_name && !info->version)
               fprintf (stderr, "Engine %s not installed properly",
                        info->file_name);
             else if (info->file_name && info->version && info->req_version)
               fprintf (stderr, "Engine %s version %s installed, "
                        "but at least version %s required", info->file_name,
                        info->version, info->req_version);
             else
               fprintf (stderr, "Unknown problem with engine for protocol %s",
                        gpgme_get_protocol_name (info->protocol));
           }
       }


File: gpgme.info,  Node: Engine Configuration,  Next: OpenPGP,  Prev: Engine Information,  Up: Protocols and Engines

3.3 Engine Configuration
========================

You can change the configuration of a backend engine, and thus change
the executable program and configuration directory to be used.  You can
make these changes the default or set them for some contexts
individually.

 -- Function: gpgme_error_t gpgme_set_engine_info
          (gpgme_protocol_t PROTO, const char *FILE_NAME,
          const char *HOME_DIR)
     SINCE: 1.1.0

     The function ‘gpgme_set_engine_info’ changes the default
     configuration of the crypto engine implementing the protocol PROTO.

     FILE_NAME is the file name of the executable program implementing
     this protocol, and HOME_DIR is the directory name of the
     configuration directory for this crypto engine.  If HOME_DIR is
     ‘NULL’, the engine’s default will be used.

     The new defaults are not applied to already created GPGME contexts.

     This function returns the error code ‘GPG_ERR_NO_ERROR’ if
     successful, or an error code on failure.

   The functions ‘gpgme_ctx_get_engine_info’ and
‘gpgme_ctx_set_engine_info’ can be used to change the engine
configuration per context.  *Note Crypto Engine::.


File: gpgme.info,  Node: OpenPGP,  Next: Cryptographic Message Syntax,  Prev: Engine Configuration,  Up: Protocols and Engines

3.4 OpenPGP
===========

OpenPGP is implemented by GnuPG, the GNU Privacy Guard.  This is the
first protocol that was supported by GPGME.

   The OpenPGP protocol is specified by ‘GPGME_PROTOCOL_OpenPGP’.


File: gpgme.info,  Node: Cryptographic Message Syntax,  Next: Assuan,  Prev: OpenPGP,  Up: Protocols and Engines

3.5 Cryptographic Message Syntax
================================

CMS is implemented by GpgSM, the S/MIME implementation for GnuPG.

   The CMS protocol is specified by ‘GPGME_PROTOCOL_CMS’.


File: gpgme.info,  Node: Assuan,  Prev: Cryptographic Message Syntax,  Up: Protocols and Engines

3.6 Assuan
==========

Assuan is the RPC library used by the various GnuPG components.  The
Assuan protocol allows one to talk to arbitrary Assuan servers using
GPGME.  *Note Using the Assuan protocol::.

   The ASSUAN protocol is specified by ‘GPGME_PROTOCOL_ASSUAN’.


File: gpgme.info,  Node: Algorithms,  Next: Error Handling,  Prev: Protocols and Engines,  Up: Top

4 Algorithms
************

The crypto backends support a variety of algorithms used in public key
cryptography.(1)  The following sections list the identifiers used to
denote such an algorithm.

* Menu:

* Public Key Algorithms::         A list of all public key algorithms.
* Hash Algorithms::               A list of all hash algorithms.

   ---------- Footnotes ----------

   (1) Some engines also provide symmetric only encryption; see the
description of the encryption function on how to use this.


File: gpgme.info,  Node: Public Key Algorithms,  Next: Hash Algorithms,  Up: Algorithms

4.1 Public Key Algorithms
=========================

Public key algorithms are used for encryption, decryption, signing and
verification of signatures.

 -- Data type: enum gpgme_pubkey_algo_t
     The ‘gpgme_pubkey_algo_t’ type specifies the set of all public key
     algorithms that are supported by GPGME.  Possible values are:

     ‘GPGME_PK_RSA’
          This value indicates the RSA (Rivest, Shamir, Adleman)
          algorithm.

     ‘GPGME_PK_RSA_E’
          Deprecated.  This value indicates the RSA (Rivest, Shamir,
          Adleman) algorithm for encryption and decryption only.

     ‘GPGME_PK_RSA_S’
          Deprecated.  This value indicates the RSA (Rivest, Shamir,
          Adleman) algorithm for signing and verification only.

     ‘GPGME_PK_DSA’
          This value indicates DSA, the Digital Signature Algorithm.

     ‘GPGME_PK_ELG’
          This value indicates ElGamal.

     ‘GPGME_PK_ELG_E’
          This value also indicates ElGamal and is used specifically in
          GnuPG.

     ‘GPGME_PK_ECC’
          SINCE: 1.5.0

          This value is a generic indicator for ellipic curve
          algorithms.

     ‘GPGME_PK_ECDSA’
          SINCE: 1.3.0

          This value indicates ECDSA, the Elliptic Curve Digital
          Signature Algorithm as defined by FIPS 186-2 and RFC-6637.

     ‘GPGME_PK_ECDH’
          SINCE: 1.3.0

          This value indicates ECDH, the Eliptic Curve Diffie-Hellmann
          encryption algorithm as defined by RFC-6637.

     ‘GPGME_PK_EDDSA’
          SINCE: 1.7.0

          This value indicates the EdDSA algorithm.

 -- Function: const char * gpgme_pubkey_algo_name
          (gpgme_pubkey_algo_t ALGO)
     The function ‘gpgme_pubkey_algo_name’ returns a pointer to a
     statically allocated string containing a description of the public
     key algorithm ALGO.  This string can be used to output the name of
     the public key algorithm to the user.

     If ALGO is not a valid public key algorithm, ‘NULL’ is returned.

 -- Function: char * gpgme_pubkey_algo_string (gpgme_subkey_t KEY)
     SINCE: 1.7.0

     The function ‘gpgme_pubkey_algo_string’ is a convenience function
     to build and return an algorithm string in the same way GnuPG does
     (e.g., “rsa2048” or “ed25519”).  The caller must free the result
     using ‘gpgme_free’.  On error (e.g., invalid argument or memory
     exhausted), the function returns NULL and sets ‘ERRNO’.


File: gpgme.info,  Node: Hash Algorithms,  Prev: Public Key Algorithms,  Up: Algorithms

4.2 Hash Algorithms
===================

Hash (message digest) algorithms are used to compress a long message to
make it suitable for public key cryptography.

 -- Data type: enum gpgme_hash_algo_t
     The ‘gpgme_hash_algo_t’ type specifies the set of all hash
     algorithms that are supported by GPGME.  Possible values are:

     ‘GPGME_MD_MD5’
     ‘GPGME_MD_SHA1’
     ‘GPGME_MD_RMD160’
     ‘GPGME_MD_MD2’
     ‘GPGME_MD_TIGER’
     ‘GPGME_MD_HAVAL’
     ‘GPGME_MD_SHA256’
     ‘GPGME_MD_SHA384’
     ‘GPGME_MD_SHA512’
     ‘GPGME_MD_SHA224’
          SINCE: 1.5.0

     ‘GPGME_MD_MD4’
     ‘GPGME_MD_CRC32’
     ‘GPGME_MD_CRC32_RFC1510’
     ‘GPGME_MD_CRC24_RFC2440’

 -- Function: const char * gpgme_hash_algo_name (gpgme_hash_algo_t ALGO)
     The function ‘gpgme_hash_algo_name’ returns a pointer to a
     statically allocated string containing a description of the hash
     algorithm ALGO.  This string can be used to output the name of the
     hash algorithm to the user.

     If ALGO is not a valid hash algorithm, ‘NULL’ is returned.


File: gpgme.info,  Node: Error Handling,  Next: Exchanging Data,  Prev: Algorithms,  Up: Top

5 Error Handling
****************

Many functions in GPGME can return an error if they fail.  For this
reason, the application should always catch the error condition and take
appropriate measures, for example by releasing the resources and passing
the error up to the caller, or by displaying a descriptive message to
the user and cancelling the operation.

   Some error values do not indicate a system error or an error in the
operation, but the result of an operation that failed properly.  For
example, if you try to decrypt a tempered message, the decryption will
fail.  Another error value actually means that the end of a data buffer
or list has been reached.  The following descriptions explain for many
error codes what they mean usually.  Some error values have specific
meanings if returned by a certain functions.  Such cases are described
in the documentation of those functions.

   GPGME uses the ‘libgpg-error’ library.  This allows to share the
error codes with other components of the GnuPG system, and thus pass
error values transparently from the crypto engine, or some helper
application of the crypto engine, to the user.  This way no information
is lost.  As a consequence, GPGME does not use its own identifiers for
error codes, but uses those provided by ‘libgpg-error’.  They usually
start with ‘GPG_ERR_’.

   However, GPGME does provide aliases for the functions defined in
libgpg-error, which might be preferred for name space consistency.

* Menu:

* Error Values::                  The error value and what it means.
* Error Sources::                 A list of important error sources.
* Error Codes::                   A list of important error codes.
* Error Strings::                 How to get a descriptive string from a value.


File: gpgme.info,  Node: Error Values,  Next: Error Sources,  Up: Error Handling

5.1 Error Values
================

 -- Data type: gpgme_err_code_t
     The ‘gpgme_err_code_t’ type is an alias for the ‘libgpg-error’ type
     ‘gpg_err_code_t’.  The error code indicates the type of an error,
     or the reason why an operation failed.

     A list of important error codes can be found in the next section.

 -- Data type: gpgme_err_source_t
     The ‘gpgme_err_source_t’ type is an alias for the ‘libgpg-error’
     type ‘gpg_err_source_t’.  The error source has not a precisely
     defined meaning.  Sometimes it is the place where the error
     happened, sometimes it is the place where an error was encoded into
     an error value.  Usually the error source will give an indication
     to where to look for the problem.  This is not always true, but it
     is attempted to achieve this goal.

     A list of important error sources can be found in the next section.

 -- Data type: gpgme_error_t
     The ‘gpgme_error_t’ type is an alias for the ‘libgpg-error’ type
     ‘gpg_error_t’.  An error value like this has always two components,
     an error code and an error source.  Both together form the error
     value.

     Thus, the error value can not be directly compared against an error
     code, but the accessor functions described below must be used.
     However, it is guaranteed that only 0 is used to indicate success
     (‘GPG_ERR_NO_ERROR’), and that in this case all other parts of the
     error value are set to 0, too.

     Note that in GPGME, the error source is used purely for
     diagnostical purposes.  Only the error code should be checked to
     test for a certain outcome of a function.  The manual only
     documents the error code part of an error value.  The error source
     is left unspecified and might be anything.

 -- Function: static inline gpgme_err_code_t gpgme_err_code
          (gpgme_error_t ERR)
     The static inline function ‘gpgme_err_code’ returns the
     ‘gpgme_err_code_t’ component of the error value ERR.  This function
     must be used to extract the error code from an error value in order
     to compare it with the ‘GPG_ERR_*’ error code macros.

 -- Function: static inline gpgme_err_source_t gpgme_err_source
          (gpgme_error_t ERR)
     The static inline function ‘gpgme_err_source’ returns the
     ‘gpgme_err_source_t’ component of the error value ERR.  This
     function must be used to extract the error source from an error
     value in order to compare it with the ‘GPG_ERR_SOURCE_*’ error
     source macros.

 -- Function: static inline gpgme_error_t gpgme_err_make
          (gpgme_err_source_t SOURCE, gpgme_err_code_t CODE)
     The static inline function ‘gpgme_err_make’ returns the error value
     consisting of the error source SOURCE and the error code CODE.

     This function can be used in callback functions to construct an
     error value to return it to the library.

 -- Function: static inline gpgme_error_t gpgme_error
          (gpgme_err_code_t CODE)
     The static inline function ‘gpgme_error’ returns the error value
     consisting of the default error source and the error code CODE.

     For GPGME applications, the default error source is
     ‘GPG_ERR_SOURCE_USER_1’.  You can define ‘GPGME_ERR_SOURCE_DEFAULT’
     before including ‘gpgme.h’ to change this default.

     This function can be used in callback functions to construct an
     error value to return it to the library.

   The ‘libgpg-error’ library provides error codes for all system error
numbers it knows about.  If ERR is an unknown error number, the error
code ‘GPG_ERR_UNKNOWN_ERRNO’ is used.  The following functions can be
used to construct error values from system errnor numbers.

 -- Function: gpgme_error_t gpgme_err_make_from_errno
          (gpgme_err_source_t SOURCE, int ERR)
     The function ‘gpgme_err_make_from_errno’ is like ‘gpgme_err_make’,
     but it takes a system error like ‘errno’ instead of a
     ‘gpgme_err_code_t’ error code.

 -- Function: gpgme_error_t gpgme_error_from_errno (int ERR)
     The function ‘gpgme_error_from_errno’ is like ‘gpgme_error’, but it
     takes a system error like ‘errno’ instead of a ‘gpgme_err_code_t’
     error code.

   Sometimes you might want to map system error numbers to error codes
directly, or map an error code representing a system error back to the
system error number.  The following functions can be used to do that.

 -- Function: gpgme_err_code_t gpgme_err_code_from_errno (int ERR)
     The function ‘gpgme_err_code_from_errno’ returns the error code for
     the system error ERR.  If ERR is not a known system error, the
     function returns ‘GPG_ERR_UNKNOWN_ERRNO’.

 -- Function: int gpgme_err_code_to_errno (gpgme_err_code_t ERR)
     The function ‘gpgme_err_code_to_errno’ returns the system error for
     the error code ERR.  If ERR is not an error code representing a
     system error, or if this system error is not defined on this
     system, the function returns ‘0’.


File: gpgme.info,  Node: Error Sources,  Next: Error Codes,  Prev: Error Values,  Up: Error Handling

5.2 Error Sources
=================

The library ‘libgpg-error’ defines an error source for every component
of the GnuPG system.  The error source part of an error value is not
well defined.  As such it is mainly useful to improve the diagnostic
error message for the user.

   If the error code part of an error value is ‘0’, the whole error
value will be ‘0’.  In this case the error source part is of course
‘GPG_ERR_SOURCE_UNKNOWN’.

   The list of error sources that might occur in applications using
GPGME is:

‘GPG_ERR_SOURCE_UNKNOWN’
     The error source is not known.  The value of this error source is
     ‘0’.

‘GPG_ERR_SOURCE_GPGME’
     The error source is GPGME itself.  This is the default for errors
     that occur in the GPGME library.

‘GPG_ERR_SOURCE_GPG’
     The error source is GnuPG, which is the crypto engine used for the
     OpenPGP protocol.

‘GPG_ERR_SOURCE_GPGSM’
     The error source is GPGSM, which is the crypto engine used for the
     CMS protocol.

‘GPG_ERR_SOURCE_GCRYPT’
     The error source is ‘libgcrypt’, which is used by crypto engines to
     perform cryptographic operations.

‘GPG_ERR_SOURCE_GPGAGENT’
     The error source is ‘gpg-agent’, which is used by crypto engines to
     perform operations with the secret key.

‘GPG_ERR_SOURCE_PINENTRY’
     The error source is ‘pinentry’, which is used by ‘gpg-agent’ to
     query the passphrase to unlock a secret key.

‘GPG_ERR_SOURCE_SCD’
     The error source is the SmartCard Daemon, which is used by
     ‘gpg-agent’ to delegate operations with the secret key to a
     SmartCard.

‘GPG_ERR_SOURCE_KEYBOX’
     The error source is ‘libkbx’, a library used by the crypto engines
     to manage local keyrings.

‘GPG_ERR_SOURCE_USER_1’
‘GPG_ERR_SOURCE_USER_2’
‘GPG_ERR_SOURCE_USER_3’
‘GPG_ERR_SOURCE_USER_4’
     These error sources are not used by any GnuPG component and can be
     used by other software.  For example, applications using GPGME can
     use them to mark error values coming from callback handlers.  Thus
     ‘GPG_ERR_SOURCE_USER_1’ is the default for errors created with
     ‘gpgme_error’ and ‘gpgme_error_from_errno’, unless you define
     ‘GPGME_ERR_SOURCE_DEFAULT’ before including ‘gpgme.h’.


File: gpgme.info,  Node: Error Codes,  Next: Error Strings,  Prev: Error Sources,  Up: Error Handling

5.3 Error Codes
===============

The library ‘libgpg-error’ defines many error values.  Most of them are
not used by ‘GPGME’ directly, but might be returned by GPGME because it
received them from the crypto engine.  The below list only includes such
error codes that have a specific meaning in ‘GPGME’, or which are so
common that you should know about them.

‘GPG_ERR_EOF’
     This value indicates the end of a list, buffer or file.

‘GPG_ERR_NO_ERROR’
     This value indicates success.  The value of this error code is ‘0’.
     Also, it is guaranteed that an error value made from the error code
     ‘0’ will be ‘0’ itself (as a whole).  This means that the error
     source information is lost for this error code, however, as this
     error code indicates that no error occurred, this is generally not
     a problem.

‘GPG_ERR_GENERAL’
     This value means that something went wrong, but either there is not
     enough information about the problem to return a more useful error
     value, or there is no separate error value for this type of
     problem.

‘GPG_ERR_ENOMEM’
     This value means that an out-of-memory condition occurred.

‘GPG_ERR_E...’
     System errors are mapped to GPG_ERR_FOO where FOO is the symbol for
     the system error.

‘GPG_ERR_INV_VALUE’
     This value means that some user provided data was out of range.
     This can also refer to objects.  For example, if an empty
     ‘gpgme_data_t’ object was expected, but one containing data was
     provided, this error value is returned.

‘GPG_ERR_UNUSABLE_PUBKEY’
     This value means that some recipients for a message were invalid.

‘GPG_ERR_UNUSABLE_SECKEY’
     This value means that some signers were invalid.

‘GPG_ERR_NO_DATA’
     This value means that a ‘gpgme_data_t’ object which was expected to
     have content was found empty.

‘GPG_ERR_CONFLICT’
     This value means that a conflict of some sort occurred.

‘GPG_ERR_NOT_IMPLEMENTED’
     This value indicates that the specific function (or operation) is
     not implemented.  This error should never happen.  It can only
     occur if you use certain values or configuration options which do
     not work, but for which we think that they should work at some
     later time.

‘GPG_ERR_DECRYPT_FAILED’
     This value indicates that a decryption operation was unsuccessful.

‘GPG_ERR_BAD_PASSPHRASE’
     This value means that the user did not provide a correct passphrase
     when requested.

‘GPG_ERR_CANCELED’
     This value means that the operation was canceled.

‘GPG_ERR_FULLY_CANCELED’
     This value means that the operation was canceled.  It is sometimes
     returned instead of ‘GPG_ERR_CANCELED’ for internal reasons in
     GnuPG. You should treat both values identically.

‘GPG_ERR_INV_ENGINE’
     This value means that the engine that implements the desired
     protocol is currently not available.  This can either be because
     the sources were configured to exclude support for this engine, or
     because the engine is not installed properly.

‘GPG_ERR_AMBIGUOUS_NAME’
     This value indicates that a user ID or other specifier did not
     specify a unique key.

‘GPG_ERR_WRONG_KEY_USAGE’
     This value indicates that a key is not used appropriately.

‘GPG_ERR_CERT_REVOKED’
     This value indicates that a key signature was revoced.

‘GPG_ERR_CERT_EXPIRED’
     This value indicates that a key signature expired.

‘GPG_ERR_NO_CRL_KNOWN’
     This value indicates that no certificate revocation list is known
     for the certificate.

‘GPG_ERR_NO_POLICY_MATCH’
     This value indicates that a policy issue occurred.

‘GPG_ERR_NO_SECKEY’
     This value indicates that no secret key for the user ID is
     available.

‘GPG_ERR_MISSING_CERT’
     This value indicates that a key could not be imported because the
     issuer certificate is missing.

‘GPG_ERR_BAD_CERT_CHAIN’
     This value indicates that a key could not be imported because its
     certificate chain is not good, for example it could be too long.

‘GPG_ERR_UNSUPPORTED_ALGORITHM’
     This value means a verification failed because the cryptographic
     algorithm is not supported by the crypto backend.

‘GPG_ERR_BAD_SIGNATURE’
     This value means a verification failed because the signature is
     bad.

‘GPG_ERR_NO_PUBKEY’
     This value means a verification failed because the public key is
     not available.

‘GPG_ERR_USER_1’
‘GPG_ERR_USER_2’
‘...’
‘GPG_ERR_USER_16’
     These error codes are not used by any GnuPG component and can be
     freely used by other software.  Applications using GPGME might use
     them to mark specific errors returned by callback handlers if no
     suitable error codes (including the system errors) for these errors
     exist already.


File: gpgme.info,  Node: Error Strings,  Prev: Error Codes,  Up: Error Handling

5.4 Error Strings
=================

 -- Function: const char * gpgme_strerror (gpgme_error_t ERR)
     The function ‘gpgme_strerror’ returns a pointer to a statically
     allocated string containing a description of the error code
     contained in the error value ERR.  This string can be used to
     output a diagnostic message to the user.

     This function is not thread safe.  Use ‘gpgme_strerror_r’ in
     multi-threaded programs.

 -- Function: int gpgme_strerror_r (gpgme_error_t ERR, char *BUF,
          size_t BUFLEN)
     The function ‘gpgme_strerror_r’ returns the error string for ERR in
     the user-supplied buffer BUF of size BUFLEN.  This function is, in
     contrast to ‘gpgme_strerror’, thread-safe if a thread-safe
     ‘strerror_r’ function is provided by the system.  If the function
     succeeds, 0 is returned and BUF contains the string describing the
     error.  If the buffer was not large enough, ERANGE is returned and
     BUF contains as much of the beginning of the error string as fits
     into the buffer.

 -- Function: const char * gpgme_strsource (gpgme_error_t ERR)
     The function ‘gpgme_strerror’ returns a pointer to a statically
     allocated string containing a description of the error source
     contained in the error value ERR.  This string can be used to
     output a diagnostic message to the user.

   The following example illustrates the use of ‘gpgme_strerror’:

     gpgme_ctx_t ctx;
     gpgme_error_t err = gpgme_new (&ctx);
     if (err)
       {
         fprintf (stderr, "%s: creating GpgME context failed: %s: %s\n",
                  argv[0], gpgme_strsource (err), gpgme_strerror (err));
         exit (1);
       }


File: gpgme.info,  Node: Exchanging Data,  Next: Contexts,  Prev: Error Handling,  Up: Top

6 Exchanging Data
*****************

A lot of data has to be exchanged between the user and the crypto
engine, like plaintext messages, ciphertext, signatures and information
about the keys.  The technical details about exchanging the data
information are completely abstracted by GPGME.  The user provides and
receives the data via ‘gpgme_data_t’ objects, regardless of the
communication protocol between GPGME and the crypto engine in use.

 -- Data type: gpgme_data_t
     The ‘gpgme_data_t’ type is a handle for a container for generic
     data, which is used by GPGME to exchange data with the user.

   ‘gpgme_data_t’ objects do not provide notifications on events.  It is
assumed that read and write operations are blocking until data is
available.  If this is undesirable, the application must ensure that all
GPGME data operations always have data available, for example by using
memory buffers or files rather than pipes or sockets.  This might be
relevant, for example, if the external event loop mechanism is used.

 -- Data type: gpgme_off_t
     SINCE: 1.4.1

     On POSIX platforms the ‘gpgme_off_t’ type is an alias for ‘off_t’;
     it may be used interchangeable.  On Windows platforms ‘gpgme_off_t’
     is defined as a long (i.e., 32 bit) for 32 bit Windows and as a 64
     bit signed integer for 64 bit Windows.

 -- Data type: gpgme_ssize_t
     The ‘gpgme_ssize_t’ type is an alias for ‘ssize_t’.  It has only
     been introduced to overcome portability problems pertaining to the
     declaration of ‘ssize_t’ by different toolchains.

* Menu:

* Creating Data Buffers::         Creating new data buffers.
* Destroying Data Buffers::       Releasing data buffers.
* Manipulating Data Buffers::     Operations on data buffers.


File: gpgme.info,  Node: Creating Data Buffers,  Next: Destroying Data Buffers,  Up: Exchanging Data

6.1 Creating Data Buffers
=========================

Data objects can be based on memory, files, or callback functions
provided by the user.  Not all operations are supported by all objects.

* Menu:

* Memory Based Data Buffers::     Creating memory based data buffers.
* File Based Data Buffers::       Creating file based data buffers.
* Callback Based Data Buffers::   Creating callback based data buffers.


File: gpgme.info,  Node: Memory Based Data Buffers,  Next: File Based Data Buffers,  Up: Creating Data Buffers

6.1.1 Memory Based Data Buffers
-------------------------------

Memory based data objects store all data in allocated memory.  This is
convenient, but only practical for an amount of data that is a fraction
of the available physical memory.  The data has to be copied from its
source and to its destination, which can often be avoided by using one
of the other data object

 -- Function: gpgme_error_t gpgme_data_new (gpgme_data_t *DH)
     The function ‘gpgme_data_new’ creates a new ‘gpgme_data_t’ object
     and returns a handle for it in DH.  The data object is memory based
     and initially empty.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, ‘GPG_ERR_INV_VALUE’ if DH is not a
     valid pointer, and ‘GPG_ERR_ENOMEM’ if not enough memory is
     available.

 -- Function: gpgme_error_t gpgme_data_new_from_mem (gpgme_data_t *DH,
          const char *BUFFER, size_t SIZE, int COPY)
     The function ‘gpgme_data_new_from_mem’ creates a new ‘gpgme_data_t’
     object and fills it with SIZE bytes starting from BUFFER.

     If COPY is not zero, a private copy of the data is made.  If COPY
     is zero, the data is taken from the specified buffer as needed, and
     the user has to ensure that the buffer remains valid for the whole
     life span of the data object.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, ‘GPG_ERR_INV_VALUE’ if DH or
     BUFFER is not a valid pointer, and ‘GPG_ERR_ENOMEM’ if not enough
     memory is available.

 -- Function: gpgme_error_t gpgme_data_new_from_file (gpgme_data_t *DH,
          const char *FILENAME, int COPY)
     The function ‘gpgme_data_new_from_file’ creates a new
     ‘gpgme_data_t’ object and fills it with the content of the file
     FILENAME.

     If COPY is not zero, the whole file is read in at initialization
     time and the file is not used anymore after that.  This is the only
     mode supported currently.  Later, a value of zero for COPY might
     cause all reads to be delayed until the data is needed, but this is
     not yet implemented.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, ‘GPG_ERR_INV_VALUE’ if DH or
     FILENAME is not a valid pointer, ‘GPG_ERR_NOT_IMPLEMENTED’ if CODE
     is zero, and ‘GPG_ERR_ENOMEM’ if not enough memory is available.

 -- Function: gpgme_error_t gpgme_data_new_from_filepart
          (gpgme_data_t *DH, const char *FILENAME, FILE *FP,
          off_t OFFSET, size_t LENGTH)
     The function ‘gpgme_data_new_from_filepart’ creates a new
     ‘gpgme_data_t’ object and fills it with a part of the file
     specified by FILENAME or FP.

     Exactly one of FILENAME and FP must be non-zero, the other must be
     zero.  The argument that is not zero specifies the file from which
     LENGTH bytes are read into the data object, starting from OFFSET.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, ‘GPG_ERR_INV_VALUE’ if DH and
     exactly one of FILENAME and FP is not a valid pointer, and
     ‘GPG_ERR_ENOMEM’ if not enough memory is available.


File: gpgme.info,  Node: File Based Data Buffers,  Next: Callback Based Data Buffers,  Prev: Memory Based Data Buffers,  Up: Creating Data Buffers

6.1.2 File Based Data Buffers
-----------------------------

File based data objects operate directly on file descriptors or streams.
Only a small amount of data is stored in core at any time, so the size
of the data objects is not limited by GPGME.

 -- Function: gpgme_error_t gpgme_data_new_from_fd (gpgme_data_t *DH,
          int FD)
     The function ‘gpgme_data_new_from_fd’ creates a new ‘gpgme_data_t’
     object and uses the file descriptor FD to read from (if used as an
     input data object) and write to (if used as an output data object).

     When using the data object as an input buffer, the function might
     read a bit more from the file descriptor than is actually needed by
     the crypto engine in the desired operation because of internal
     buffering.

     Note that GPGME assumes that the file descriptor is set to blocking
     mode.  Errors during I/O operations, except for EINTR, are usually
     fatal for crypto operations.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, and ‘GPG_ERR_ENOMEM’ if not enough
     memory is available.

 -- Function: gpgme_error_t gpgme_data_new_from_stream
          (gpgme_data_t *DH, FILE *STREAM)
     The function ‘gpgme_data_new_from_stream’ creates a new
     ‘gpgme_data_t’ object and uses the I/O stream STREAM to read from
     (if used as an input data object) and write to (if used as an
     output data object).

     When using the data object as an input buffer, the function might
     read a bit more from the stream than is actually needed by the
     crypto engine in the desired operation because of internal
     buffering.

     Note that GPGME assumes that the stream is in blocking mode.
     Errors during I/O operations, except for EINTR, are usually fatal
     for crypto operations.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, and ‘GPG_ERR_ENOMEM’ if not enough
     memory is available.

 -- Function: gpgme_error_t gpgme_data_new_from_estream
          (gpgme_data_t *DH, gpgrt_stream_t STREAM)
     The function ‘gpgme_data_new_from_estream’ creates a new
     ‘gpgme_data_t’ object and uses the gpgrt stream STREAM to read from
     (if used as an input data object) and write to (if used as an
     output data object).

     When using the data object as an input buffer, the function might
     read a bit more from the stream than is actually needed by the
     crypto engine in the desired operation because of internal
     buffering.

     Note that GPGME assumes that the stream is in blocking mode.
     Errors during I/O operations, except for EINTR, are usually fatal
     for crypto operations.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, and ‘GPG_ERR_ENOMEM’ if not enough
     memory is available.


File: gpgme.info,  Node: Callback Based Data Buffers,  Prev: File Based Data Buffers,  Up: Creating Data Buffers

6.1.3 Callback Based Data Buffers
---------------------------------

If neither memory nor file based data objects are a good fit for your
application, you can implement the functions a data object provides
yourself and create a data object from these callback functions.

 -- Data type: ssize_t (*gpgme_data_read_cb_t) (void *HANDLE,
          void *BUFFER, size_t SIZE)
     The ‘gpgme_data_read_cb_t’ type is the type of functions which
     GPGME calls if it wants to read data from a user-implemented data
     object.  The function should read up to SIZE bytes from the current
     read position into the space starting at BUFFER.  The HANDLE is
     provided by the user at data object creation time.

     Note that GPGME assumes that the read blocks until data is
     available.  Errors during I/O operations, except for EINTR, are
     usually fatal for crypto operations.

     The function should return the number of bytes read, 0 on EOF, and
     -1 on error.  If an error occurs, ERRNO should be set to describe
     the type of the error.

 -- Data type: ssize_t (*gpgme_data_write_cb_t) (void *HANDLE,
          const void *BUFFER, size_t SIZE)
     The ‘gpgme_data_write_cb_t’ type is the type of functions which
     GPGME calls if it wants to write data to a user-implemented data
     object.  The function should write up to SIZE bytes to the current
     write position from the space starting at BUFFER.  The HANDLE is
     provided by the user at data object creation time.

     Note that GPGME assumes that the write blocks until data is
     available.  Errors during I/O operations, except for EINTR, are
     usually fatal for crypto operations.

     The function should return the number of bytes written, and -1 on
     error.  If an error occurs, ERRNO should be set to describe the
     type of the error.

 -- Data type: off_t (*gpgme_data_seek_cb_t) (void *HANDLE,
          off_t OFFSET, int WHENCE)
     The ‘gpgme_data_seek_cb_t’ type is the type of functions which
     GPGME calls if it wants to change the current read/write position
     in a user-implemented data object, just like the ‘lseek’ function.

     The function should return the new read/write position, and -1 on
     error.  If an error occurs, ERRNO should be set to describe the
     type of the error.

 -- Data type: void (*gpgme_data_release_cb_t) (void *HANDLE)
     The ‘gpgme_data_release_cb_t’ type is the type of functions which
     GPGME calls if it wants to destroy a user-implemented data object.
     The HANDLE is provided by the user at data object creation time.

 -- Data type: struct gpgme_data_cbs
     This structure is used to store the data callback interface
     functions described above.  It has the following members:

     ‘gpgme_data_read_cb_t read’
          This is the function called by GPGME to read data from the
          data object.  It is only required for input data object.

     ‘gpgme_data_write_cb_t write’
          This is the function called by GPGME to write data to the data
          object.  It is only required for output data object.

     ‘gpgme_data_seek_cb_t seek’
          This is the function called by GPGME to change the current
          read/write pointer in the data object (if available).  It is
          optional.

     ‘gpgme_data_release_cb_t release’
          This is the function called by GPGME to release a data object.
          It is optional.

 -- Function: gpgme_error_t gpgme_data_new_from_cbs (gpgme_data_t *DH,
          gpgme_data_cbs_t CBS, void *HANDLE)
     The function ‘gpgme_data_new_from_cbs’ creates a new ‘gpgme_data_t’
     object and uses the user-provided callback functions to operate on
     the data object.

     The handle HANDLE is passed as first argument to the callback
     functions.  This can be used to identify this data object.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the data
     object was successfully created, and ‘GPG_ERR_ENOMEM’ if not enough
     memory is available.


File: gpgme.info,  Node: Destroying Data Buffers,  Next: Manipulating Data Buffers,  Prev: Creating Data Buffers,  Up: Exchanging Data

6.2 Destroying Data Buffers
===========================

 -- Function: void gpgme_data_release (gpgme_data_t DH)
     The function ‘gpgme_data_release’ destroys the data object with the
     handle DH.  It releases all associated resources that were not
     provided by the user in the first place.

 -- Function: char * gpgme_data_release_and_get_mem (gpgme_data_t DH,
          size_t *LENGTH)
     The function ‘gpgme_data_release_and_get_mem’ is like
     ‘gpgme_data_release’, except that it returns the data buffer and
     its length that was provided by the object.

     The user has to release the buffer with ‘gpgme_free’.  In case the
     user provided the data buffer in non-copy mode, a copy will be made
     for this purpose.

     In case an error returns, or there is no suitable data buffer that
     can be returned to the user, the function will return ‘NULL’.  In
     any case, the data object DH is destroyed.

 -- Function: void gpgme_free (void *BUFFER)
     SINCE: 1.1.1

     The function ‘gpgme_free’ releases the memory returned by
     ‘gpgme_data_release_and_get_mem’ and ‘gpgme_pubkey_algo_string’.
     It should be used instead of the system libraries ‘free’ function
     in case different allocators are used by a program.  This is often
     the case if gpgme is used under Windows as a DLL.


File: gpgme.info,  Node: Manipulating Data Buffers,  Prev: Destroying Data Buffers,  Up: Exchanging Data

6.3 Manipulating Data Buffers
=============================

Data buffers contain data and meta-data.  The following operations can
be used to manipulate both.

* Menu:

* Data Buffer I/O Operations::    I/O operations on data buffers.
* Data Buffer Meta-Data::         Meta-data manipulation of data buffers.
* Data Buffer Convenience::       Convenience function for data buffers.


File: gpgme.info,  Node: Data Buffer I/O Operations,  Next: Data Buffer Meta-Data,  Up: Manipulating Data Buffers

6.3.1 Data Buffer I/O Operations
--------------------------------

 -- Function: ssize_t gpgme_data_read (gpgme_data_t DH, void *BUFFER,
          size_t LENGTH)
     The function ‘gpgme_data_read’ reads up to LENGTH bytes from the
     data object with the handle DH into the space starting at BUFFER.

     If no error occurs, the actual amount read is returned.  If the end
     of the data object is reached, the function returns 0.

     In all other cases, the function returns -1 and sets ERRNO.

 -- Function: ssize_t gpgme_data_write (gpgme_data_t DH,
          const void *BUFFER, size_t SIZE)
     The function ‘gpgme_data_write’ writes up to SIZE bytes starting
     from BUFFER into the data object with the handle DH at the current
     write position.

     The function returns the number of bytes actually written, or -1 if
     an error occurs.  If an error occurs, ERRNO is set.

 -- Function: off_t gpgme_data_seek (gpgme_data_t DH, off_t OFFSET,
          int WHENCE)
     The function ‘gpgme_data_seek’ changes the current read/write
     position.

     The WHENCE argument specifies how the OFFSET should be interpreted.
     It must be one of the following symbolic constants:

     ‘SEEK_SET’
          Specifies that OFFSET is a count of characters from the
          beginning of the data object.

     ‘SEEK_CUR’
          Specifies that OFFSET is a count of characters from the
          current file position.  This count may be positive or
          negative.

     ‘SEEK_END’
          Specifies that OFFSET is a count of characters from the end of
          the data object.  A negative count specifies a position within
          the current extent of the data object; a positive count
          specifies a position past the current end.  If you set the
          position past the current end, and actually write data, you
          will extend the data object with zeros up to that position.

     If successful, the function returns the resulting file position,
     measured in bytes from the beginning of the data object.  You can
     use this feature together with ‘SEEK_CUR’ to read the current
     read/write position.

     If the function fails, -1 is returned and ERRNO is set.


File: gpgme.info,  Node: Data Buffer Meta-Data,  Next: Data Buffer Convenience,  Prev: Data Buffer I/O Operations,  Up: Manipulating Data Buffers

6.3.2 Data Buffer Meta-Data
---------------------------

 -- Function: char * gpgme_data_get_file_name (gpgme_data_t DH)
     SINCE: 1.1.0

     The function ‘gpgme_data_get_file_name’ returns a pointer to a
     string containing the file name associated with the data object.
     The file name will be stored in the output when encrypting or
     signing the data and will be returned to the user when decrypting
     or verifying the output data.

     If no error occurs, the string containing the file name is
     returned.  Otherwise, ‘NULL’ will be returned.

 -- Function: gpgme_error_t gpgme_data_set_file_name (gpgme_data_t DH,
          const char *FILE_NAME)
     SINCE: 1.1.0

     The function ‘gpgme_data_set_file_name’ sets the file name
     associated with the data object.  The file name will be stored in
     the output when encrypting or signing the data and will be returned
     to the user when decrypting or verifying the output data.

     If a signed or encrypted archive is created, then the file name
     will be interpreted as the base directory for the relative paths of
     the files and directories to put into the archive.  This
     corresponds to the –directory option of gpgtar.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if DH is
     not a valid pointer and ‘GPG_ERR_ENOMEM’ if not enough memory is
     available.

 -- Data type: enum gpgme_data_encoding_t
     The ‘gpgme_data_encoding_t’ type specifies the encoding of a
     ‘gpgme_data_t’ object.  For input data objects, the encoding is
     useful to give the backend a hint on the type of data.  For output
     data objects, the encoding can specify the output data format on
     certain operations.  Please note that not all backends support all
     encodings on all operations.  The following data types are
     available:

     ‘GPGME_DATA_ENCODING_NONE’
          This specifies that the encoding is not known.  This is the
          default for a new data object.  The backend will try its best
          to detect the encoding automatically.

     ‘GPGME_DATA_ENCODING_BINARY’
          This specifies that the data is encoding in binary form; i.e.,
          there is no special encoding.

     ‘GPGME_DATA_ENCODING_BASE64’
          This specifies that the data is encoded using the Base-64
          encoding scheme as used by MIME and other protocols.

     ‘GPGME_DATA_ENCODING_ARMOR’
          This specifies that the data is encoded in an armored form as
          used by OpenPGP and PEM.

     ‘GPGME_DATA_ENCODING_MIME’
          SINCE: 1.7.0

          This specifies that the data is encoded as a MIME part.

     ‘GPGME_DATA_ENCODING_URL’
          SINCE: 1.2.0

          The data is a list of linefeed delimited URLs.  This is only
          useful with ‘gpgme_op_import’.

     ‘GPGME_DATA_ENCODING_URL0’
          SINCE: 1.2.0

          The data is a list of binary zero delimited URLs.  This is
          only useful with ‘gpgme_op_import’.

     ‘GPGME_DATA_ENCODING_URLESC’
          SINCE: 1.2.0

          The data is a list of linefeed delimited URLs with all control
          and space characters percent escaped.  This mode is is not yet
          implemented.

 -- Function: gpgme_data_encoding_t gpgme_data_get_encoding
          (gpgme_data_t DH)
     The function ‘gpgme_data_get_encoding’ returns the encoding of the
     data object with the handle DH.  If DH is not a valid pointer
     (e.g., ‘NULL’) ‘GPGME_DATA_ENCODING_NONE’ is returned.

 -- Function: gpgme_error_t gpgme_data_set_encoding
          (gpgme_data_t DH, gpgme_data_encoding_t ENC)
     The function ‘gpgme_data_set_encoding’ changes the encoding of the
     data object with the handle DH to ENC.

 -- Function: gpgme_error_t gpgme_data_set_flag (gpgme_data_t DH,
          const char *NAME, const char *VALUE)

     SINCE: 1.7.0

     Some minor properties of the data object can be controlled with
     flags set by this function.  The properties are identified by the
     following values for NAME:

     ‘size-hint’
          The value is a decimal number with the length gpgme shall
          assume for this data object.  This is useful if the data is
          provided by callbacks or via file descriptors but the
          applications knows the total size of the data.  If this is set
          the OpenPGP engine may use this to decide on buffer allocation
          strategies and to provide a total value for its progress
          information.

     ‘io-buffer-size’
          The value is a decimal number with the length of internal
          buffers to used for internal I/O operations.  The value is
          capped at 1048576 (1 MiB). In certain environments large
          buffers can yield a performance boost for callback bases data
          object, but the details depend a lot on the circumstances and
          the operating system.  This flag may only be set once and must
          be set before any actual I/O happens ion the data objects.

     ‘sensitive’
          If the numeric value is not 0 the data object is considered to
          contain sensitive information like passwords or key material.
          If this is set the internal buffers are securely overwritten
          with zeroes by gpgme_data_release.

     This function returns ‘0’ on success.


File: gpgme.info,  Node: Data Buffer Convenience,  Prev: Data Buffer Meta-Data,  Up: Manipulating Data Buffers

6.3.3 Data Buffer Convenience Functions
---------------------------------------

 -- Data type: enum gpgme_data_type_t
     SINCE: 1.4.3

     The ‘gpgme_data_type_t’ type is used to return the detected type of
     the content of a data buffer.

‘GPGME_DATA_TYPE_INVALID’
     This is returned by ‘gpgme_data_identify’ if it was not possible to
     identify the data.  Reasons for this might be a non-seekable stream
     or a memory problem.  The value is 0.
‘GPGME_DATA_TYPE_UNKNOWN’
     The type of the data is not known.
‘GPGME_DATA_TYPE_PGP_SIGNED’
     The data is an OpenPGP signed message.  This may be a binary
     signature, a detached one or a cleartext signature.
‘GPGME_DATA_TYPE_PGP_ENCRYPTED’
     SINCE: 1.7.0

     The data is an OpenPGP encrypted message.
‘GPGME_DATA_TYPE_PGP_SIGNATURE’
     SINCE: 1.7.0

     The data is an OpenPGP detached signature.
‘GPGME_DATA_TYPE_PGP_OTHER’
     This is a generic OpenPGP message.  In most cases this will be
     encrypted data.
‘GPGME_DATA_TYPE_PGP_KEY’
     This is an OpenPGP key (private or public).
‘GPGME_DATA_TYPE_CMS_SIGNED’
     This is a CMS signed message.
‘GPGME_DATA_TYPE_CMS_ENCRYPTED’
     This is a CMS encrypted (enveloped data) message.
‘GPGME_DATA_TYPE_CMS_OTHER’
     This is used for other CMS message types.
‘GPGME_DATA_TYPE_X509_CERT’
     The data is a X.509 certificate
‘GPGME_DATA_TYPE_PKCS12’
     The data is a PKCS#12 message.  This is commonly used to exchange
     private keys for X.509.

 -- Function: gpgme_data_type_t gpgme_data_identify
          (gpgme_data_t DH, int RESERVED)
     SINCE: 1.4.3

     The function ‘gpgme_data_identify’ returns the type of the data
     with the handle DH.  If it is not possible to perform the
     identification, the function returns zero
     (‘GPGME_DATA_TYPE_INVALID’).  Note that depending on how the data
     object has been created the identification may not be possible or
     the data object may change its internal state (file pointer moved).
     For file or memory based data object, the state should not change.
     RESERVED should be zero.


File: gpgme.info,  Node: Contexts,  Next: UI Server Protocol,  Prev: Exchanging Data,  Up: Top

7 Contexts
**********

All cryptographic operations in GPGME are performed within a context,
which contains the internal state of the operation as well as
configuration parameters.  By using several contexts you can run several
cryptographic operations in parallel, with different configuration.

 -- Data type: gpgme_ctx_t
     The ‘gpgme_ctx_t’ type is a handle for a GPGME context, which is
     used to hold the configuration, status and result of cryptographic
     operations.

* Menu:

* Creating Contexts::             Creating new GPGME contexts.
* Destroying Contexts::           Releasing GPGME contexts.
* Result Management::             Managing the result of crypto operations.
* Context Attributes::            Setting properties of a context.
* Key Management::                Managing keys with GPGME.
* Crypto Operations::             Using a context for cryptography.
* Miscellaneous::                 Miscellaneous operations
* Run Control::                   Controlling how operations are run.


File: gpgme.info,  Node: Creating Contexts,  Next: Destroying Contexts,  Up: Contexts

7.1 Creating Contexts
=====================

 -- Function: gpgme_error_t gpgme_new (gpgme_ctx_t *CTX)
     The function ‘gpgme_new’ creates a new ‘gpgme_ctx_t’ object and
     returns a handle for it in CTX.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     context was successfully created, ‘GPG_ERR_INV_VALUE’ if CTX is not
     a valid pointer, and ‘GPG_ERR_ENOMEM’ if not enough memory is
     available.  Also, it returns ‘GPG_ERR_NOT_OPERATIONAL’ if
     ‘gpgme_check_version’ was not called to initialize GPGME, and
     ‘GPG_ERR_SELFTEST_FAILED’ if a selftest failed.  Currently, the
     only selftest is for Windows MingW32 targets to see if
     ‘-mms-bitfields’ was used (as required).


File: gpgme.info,  Node: Destroying Contexts,  Next: Result Management,  Prev: Creating Contexts,  Up: Contexts

7.2 Destroying Contexts
=======================

 -- Function: void gpgme_release (gpgme_ctx_t CTX)
     The function ‘gpgme_release’ destroys the context with the handle
     CTX and releases all associated resources.


File: gpgme.info,  Node: Result Management,  Next: Context Attributes,  Prev: Destroying Contexts,  Up: Contexts

7.3 Result Management
=====================

The detailed result of an operation is returned in operation-specific
structures such as ‘gpgme_decrypt_result_t’.  The corresponding
retrieval functions such as ‘gpgme_op_decrypt_result’ provide static
access to the results after an operation completes.  Those structures
shall be considered read-only and an application must not allocate such
a structure on its own.  The following interfaces make it possible to
detach a result structure from its associated context and give it a
lifetime beyond that of the current operation or context.

 -- Function: void gpgme_result_ref (void *RESULT)
     SINCE: 1.2.0

     The function ‘gpgme_result_ref’ acquires an additional reference
     for the result RESULT, which may be of any type ‘gpgme_*_result_t’.
     As long as the user holds a reference, the result structure is
     guaranteed to be valid and unmodified.

 -- Function: void gpgme_result_unref (void *RESULT)
     SINCE: 1.2.0

     The function ‘gpgme_result_unref’ releases a reference for the
     result RESULT.  If this was the last reference, the result
     structure will be destroyed and all resources associated to it will
     be released.

   Note that a context may hold its own references to result structures,
typically until the context is destroyed or the next operation is
started.  In fact, these references are accessed through the
‘gpgme_op_*_result’ functions.


File: gpgme.info,  Node: Context Attributes,  Next: Key Management,  Prev: Result Management,  Up: Contexts

7.4 Context Attributes
======================

* Menu:

* Protocol Selection::            Selecting the protocol used by a context.
* Crypto Engine::                 Configuring the crypto engine.
* Setting the Sender::            How to tell the engine the sender.
* ASCII Armor::                   Requesting ASCII armored output.
* Text Mode::                     Choosing canonical text mode.
* Offline Mode::                  Choosing offline mode.
* Pinentry Mode::                 Choosing the pinentry mode.
* Included Certificates::         Including a number of certificates.
* Key Listing Mode::              Selecting key listing mode.
* Passphrase Callback::           Getting the passphrase from the user.
* Progress Meter Callback::       Being informed about the progress.
* Status Message Callback::       Status messages received from gpg.
* Context Flags::                 Additional flags for a context.
* Locale::                        Setting the locale of a context.
* Additional Logs::               Additional logs of a context.


File: gpgme.info,  Node: Protocol Selection,  Next: Crypto Engine,  Up: Context Attributes

7.4.1 Protocol Selection
------------------------

 -- Function: gpgme_error_t gpgme_set_protocol (gpgme_ctx_t CTX,
          gpgme_protocol_t PROTO)
     The function ‘gpgme_set_protocol’ sets the protocol used within the
     context CTX to PROTO.  All crypto operations will be performed by
     the crypto engine configured for that protocol.  *Note Protocols
     and Engines::.

     Setting the protocol with ‘gpgme_set_protocol’ does intentionally
     not check if the crypto engine for that protocol is available and
     installed correctly.  *Note Engine Version Check::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     protocol could be set successfully, and ‘GPG_ERR_INV_VALUE’ if
     PROTOCOL is not a valid protocol.

 -- Function: gpgme_protocol_t gpgme_get_protocol (gpgme_ctx_t CTX)
     The function ‘gpgme_get_protocol’ retrieves the protocol currently
     use with the context CTX.


File: gpgme.info,  Node: Crypto Engine,  Next: Setting the Sender,  Prev: Protocol Selection,  Up: Context Attributes

7.4.2 Crypto Engine
-------------------

The following functions can be used to set and retrieve the
configuration of the crypto engines of a specific context.  The default
can also be retrieved without any particular context.  *Note Engine
Information::.  The default can also be changed globally.  *Note Engine
Configuration::.

 -- Function: gpgme_engine_info_t gpgme_ctx_get_engine_info
          (gpgme_ctx_t CTX)
     SINCE: 1.1.0

     The function ‘gpgme_ctx_get_engine_info’ returns a linked list of
     engine info structures.  Each info structure describes the
     configuration of one configured backend, as used by the context
     CTX.

     The result is valid until the next invocation of
     ‘gpgme_ctx_set_engine_info’ for this particular context.

     This function can not fail.

 -- Function: gpgme_error_t gpgme_ctx_set_engine_info (gpgme_ctx_t CTX,
          gpgme_protocol_t PROTO, const char *FILE_NAME,
          const char *HOME_DIR)
     SINCE: 1.1.0

     The function ‘gpgme_ctx_set_engine_info’ changes the configuration
     of the crypto engine implementing the protocol PROTO for the
     context CTX.

     FILE_NAME is the file name of the executable program implementing
     this protocol, and HOME_DIR is the directory name of the
     configuration directory for this crypto engine.  If HOME_DIR is
     ‘NULL’, the engine’s default will be used.

     Currently this function must be used before starting the first
     crypto operation.  It is unspecified if and when the changes will
     take effect if the function is called after starting the first
     operation on the context CTX.

     This function returns the error code ‘GPG_ERR_NO_ERROR’ if
     successful, or an error code on failure.


File: gpgme.info,  Node: Setting the Sender,  Next: ASCII Armor,  Prev: Crypto Engine,  Up: Context Attributes

7.4.3 How to tell the engine the sender.
----------------------------------------

Some engines can make use of the sender’s address, for example to figure
out the best user id in certain trust models.  For verification and
signing of mails, it is thus suggested to let the engine know the sender
("From:") address.  GPGME provides two functions to accomplish that.
Note that the esoteric use of multiple "From:" addresses is not
supported.

 -- Function: gpgme_error_t gpgme_set_sender (gpgme_ctx_t CTX,
          int ADDRESS)

     SINCE: 1.8.0

     The function ‘gpgme_set_sender’ specifies the sender address for
     use in sign and verify operations.  ADDRESS is expected to be the
     “addr-spec” part of an address but may also be a complete mailbox
     address, in which case this function extracts the “addr-spec” from
     it.  Using ‘NULL’ for ADDRESS clears the sender address.

     The function returns 0 on success or an error code on failure.  The
     most likely failure is that no valid “addr-spec” was found in
     ADDRESS.

 -- Function: const char * gpgme_get_sender (gpgme_ctx_t CTX)

     SINCE: 1.8.0

     The function ‘gpgme_get_sender’ returns the current sender address
     from the context, or NULL if none was set.  The returned value is
     valid as long as the CTX is valid and ‘gpgme_set_sender’ has not
     been called again.


File: gpgme.info,  Node: ASCII Armor,  Next: Text Mode,  Prev: Setting the Sender,  Up: Context Attributes

7.4.4 ASCII Armor
-----------------

 -- Function: void gpgme_set_armor (gpgme_ctx_t CTX, int YES)
     The function ‘gpgme_set_armor’ specifies if the output should be
     ASCII armored.  By default, output is not ASCII armored.

     ASCII armored output is disabled if YES is zero, and enabled
     otherwise.

 -- Function: int gpgme_get_armor (gpgme_ctx_t CTX)
     The function ‘gpgme_get_armor’ returns 1 if the output is ASCII
     armored, and ‘0’ if it is not, or if CTX is not a valid pointer.


File: gpgme.info,  Node: Text Mode,  Next: Offline Mode,  Prev: ASCII Armor,  Up: Context Attributes

7.4.5 Text Mode
---------------

 -- Function: void gpgme_set_textmode (gpgme_ctx_t CTX, int YES)
     The function ‘gpgme_set_textmode’ specifies if canonical text mode
     should be used.  By default, text mode is not used.

     Text mode is for example used for the RFC2015 signatures; note that
     the updated RFC 3156 mandates that the mail user agent does some
     preparations so that text mode is not needed anymore.

     This option is only relevant to the OpenPGP crypto engine, and
     ignored by all other engines.

     Canonical text mode is disabled if YES is zero, and enabled
     otherwise.

 -- Function: int gpgme_get_textmode (gpgme_ctx_t CTX)
     The function ‘gpgme_get_textmode’ returns 1 if canonical text mode
     is enabled, and ‘0’ if it is not, or if CTX is not a valid pointer.


File: gpgme.info,  Node: Offline Mode,  Next: Pinentry Mode,  Prev: Text Mode,  Up: Context Attributes

7.4.6 Offline Mode
------------------

 -- Function: void gpgme_set_offline (gpgme_ctx_t CTX, int YES)
     SINCE: 1.6.0

     The function ‘gpgme_set_offline’ specifies if offline mode should
     be used.  Offline mode is disabled if YES is zero, and enabled
     otherwise.  By default, offline mode is disabled.

     The details of the offline mode depend on the used protocol and its
     backend engine.  It may eventually be extended to be more stricter
     and for example completely disable the use of Dirmngr for any
     engine.

     For the CMS protocol the offline mode specifies whether Dirmngr
     shall be used to do additional validation that might require
     connecting external services (e.g., CRL / OCSP checks).  The
     offline mode is used for all operations on this context.  It has
     only an effect with GnuPG versions 2.1.6 or later.

     For the OpenPGP protocol offline mode entirely disables the use of
     the Dirmngr and will thus guarantee that no network connections are
     done as part of an operation on this context.  It has only an
     effect with GnuPG versions 2.1.23 or later.

     For all other protocols the offline mode is currently ignored.

 -- Function: int gpgme_get_offline (gpgme_ctx_t CTX)
     SINCE: 1.6.0

     The function ‘gpgme_get_offline’ returns 1 if offline mode is
     enabled, and ‘0’ if it is not, or if CTX is not a valid pointer.


File: gpgme.info,  Node: Pinentry Mode,  Next: Included Certificates,  Prev: Offline Mode,  Up: Context Attributes

7.4.7 Pinentry Mode
-------------------

 -- Function: gpgme_error_t gpgme_set_pinentry_mode (gpgme_ctx_t CTX,
     gpgme_pinentry_mode_t MODE)

     SINCE: 1.4.0

     The function ‘gpgme_set_pinentry_mode’ specifies the pinentry mode
     to be used.

     For GnuPG >= 2.1 this option is required to be set to
     ‘GPGME_PINENTRY_MODE_LOOPBACK’ to enable the passphrase callback
     mechanism in GPGME through ‘gpgme_set_passphrase_cb’.

 -- Function: gpgme_pinentry_mode_t gpgme_get_pinentry_mode
          (gpgme_ctx_t CTX)
     SINCE: 1.4.0

     The function ‘gpgme_get_pinenty_mode’ returns the mode set for the
     context.

 -- Data type: enum gpgme_pinentry_mode_t
     SINCE: 1.4.0

     The ‘gpgme_minentry_mode_t’ type specifies the set of possible
     pinentry modes that are supported by GPGME if GnuPG >= 2.1 is used.
     The following modes are supported:

     ‘GPGME_PINENTRY_MODE_DEFAULT’
          SINCE: 1.4.0

          Use the default of the agent, which is ask.

     ‘GPGME_PINENTRY_MODE_ASK’
          SINCE: 1.4.0

          Force the use of the Pinentry.

     ‘GPGME_PINENTRY_MODE_CANCEL’
          SINCE: 1.4.0

          Emulate use of Pinentry’s cancel button.

     ‘GPGME_PINENTRY_MODE_ERROR’
          SINCE: 1.4.0

          Return a Pinentry error ‘No Pinentry’.

     ‘GPGME_PINENTRY_MODE_LOOPBACK’
          SINCE: 1.4.0

          Redirect Pinentry queries to the caller.  This enables the use
          of ‘gpgme_set_passphrase_cb’ because pinentry queries are
          redirected to gpgme.

          Note: For 2.1.0 - 2.1.12 this mode requires
          ‘allow-loopback-pinentry’ to be enabled in the
          ‘gpg-agent.conf’ or an agent started with that option.


File: gpgme.info,  Node: Included Certificates,  Next: Key Listing Mode,  Prev: Pinentry Mode,  Up: Context Attributes

7.4.8 Included Certificates
---------------------------

 -- Function: void gpgme_set_include_certs (gpgme_ctx_t CTX,
          int NR_OF_CERTS)
     The function ‘gpgme_set_include_certs’ specifies how many
     certificates should be included in an S/MIME signed message.  By
     default, only the sender’s certificate is included.  The possible
     values of NR_OF_CERTS are:

     ‘GPGME_INCLUDE_CERTS_DEFAULT’
          SINCE: 1.0.3

          Fall back to the default of the crypto backend.  This is the
          default for GPGME.
     ‘-2’
          Include all certificates except the root certificate.
     ‘-1’
          Include all certificates.
     ‘0’
          Include no certificates.
     ‘1’
          Include the sender’s certificate only.
     ‘n’
          Include the first n certificates of the certificates path,
          starting from the sender’s certificate.  The number ‘n’ must
          be positive.

     Values of NR_OF_CERTS smaller than -2 are undefined.

     This option is only relevant to the CMS crypto engine, and ignored
     by all other engines.

 -- Function: int gpgme_get_include_certs (gpgme_ctx_t CTX)
     The function ‘gpgme_get_include_certs’ returns the number of
     certificates to include into an S/MIME signed message.


File: gpgme.info,  Node: Key Listing Mode,  Next: Passphrase Callback,  Prev: Included Certificates,  Up: Context Attributes

7.4.9 Key Listing Mode
----------------------

 -- Function: gpgme_error_t gpgme_set_keylist_mode (gpgme_ctx_t CTX,
          gpgme_keylist_mode_t MODE)
     The function ‘gpgme_set_keylist_mode’ changes the default behaviour
     of the key listing functions.  The value in MODE is a bitwise-or
     combination of one or multiple of the following bit values:

     ‘GPGME_KEYLIST_MODE_LOCAL’
          The ‘GPGME_KEYLIST_MODE_LOCAL’ symbol specifies that the local
          keyring should be searched for keys in the keylisting
          operation.  This is the default.

          Using only this option results in a ‘--list-keys’.

     ‘GPGME_KEYLIST_MODE_EXTERN’
          The ‘GPGME_KEYLIST_MODE_EXTERN’ symbol specifies that an
          external source should be searched for keys in the keylisting
          operation.  The type of external source is dependent on the
          crypto engine used and whether it is combined with
          ‘GPGME_KEYLIST_MODE_LOCAL’.  For example, it can be a remote
          keyserver or LDAP certificate server.

          Using only this option results in a ‘--search-keys’ for
          ‘GPGME_PROTOCOL_OpenPGP’ and something similar to
          ‘--list-external-keys’ for ‘GPGME_PROTOCOL_CMS’.

     ‘GPGME_KEYLIST_MODE_LOCATE’
          This is a shortcut for the combination of
          ‘GPGME_KEYLIST_MODE_LOCAL’ and ‘GPGME_KEYLIST_MODE_EXTERN’,
          which results in a ‘--locate-keys’ for
          ‘GPGME_PROTOCOL_OpenPGP’.

     ‘GPGME_KEYLIST_MODE_SIGS’
          The ‘GPGME_KEYLIST_MODE_SIGS’ symbol specifies that the key
          signatures should be included in the listed keys.

     ‘GPGME_KEYLIST_MODE_SIG_NOTATIONS’
          SINCE: 1.1.1

          The ‘GPGME_KEYLIST_MODE_SIG_NOTATIONS’ symbol specifies that
          the signature notations on key signatures should be included
          in the listed keys.  This only works if
          ‘GPGME_KEYLIST_MODE_SIGS’ is also enabled.

     ‘GPGME_KEYLIST_MODE_WITH_TOFU’
          SINCE: 1.7.0

          The ‘GPGME_KEYLIST_MODE_WITH_TOFU’ symbol specifies that
          information pertaining to the TOFU trust model should be
          included in the listed keys.

     ‘GPGME_KEYLIST_MODE_WITH_KEYGRIP’
          SINCE: 1.14.0

          The ‘GPGME_KEYLIST_MODE_WITH_KEYRIP’ symbol specifies that the
          keygrip is always included in the listing.  The default
          depends on the version of the backend and the used protocol.

     ‘GPGME_KEYLIST_MODE_WITH_SECRET’
          SINCE: 1.5.1

          The ‘GPGME_KEYLIST_MODE_WITH_SECRET’ returns information about
          the presence of a corresponding secret key in a public key
          listing.  A public key listing with this mode is slower than a
          standard listing but can be used instead of a second run to
          list the secret keys.  This is only supported for GnuPG
          versions >= 2.1.  Note that using this option also makes sure
          that the keygrip is available in the output.

     ‘GPGME_KEYLIST_MODE_EPHEMERAL’
          SINCE: 1.2.0

          The ‘GPGME_KEYLIST_MODE_EPHEMERAL’ symbol specifies that keys
          flagged as ephemeral are included in the listing.

     ‘GPGME_KEYLIST_MODE_WITH_V5FPR’
          SINCE: 1.23.0

          The ‘GPGME_KEYLIST_MODE_WITH_V5FPR’ symbol specifies that key
          listings shall also provide v5 style fingerprints for v4
          OpenPGp keys.

     ‘GPGME_KEYLIST_MODE_VALIDATE’
          SINCE: 0.4.5

          The ‘GPGME_KEYLIST_MODE_VALIDATE’ symbol specifies that the
          backend should do key or certificate validation and not just
          get the validity information from an internal cache.  This
          might be an expensive operation and is in general not useful.
          Currently only implemented for the S/MIME backend and ignored
          for other backends.

     ‘GPGME_KEYLIST_MODE_FORCE_EXTERN’
          SINCE: 1.18.0

          The ‘GPGME_KEYLIST_MODE_FORCE_EXTERN’ symbol specifies that
          only external sources should be searched for keys in the
          keylisting operation.  If used in combination with
          ‘GPGME_KEYLIST_MODE_LOCATE’, the keylisting results in a
          ‘--locate-external-keys’ for ‘GPGME_PROTOCOL_OpenPGP’.  The
          combination with ‘GPGME_KEYLIST_MODE_LOCAL’, but without
          ‘GPGME_KEYLIST_MODE_EXTERN’ is not allowed.  Currently only
          implemented for the OpenPGP backend and ignored for other
          backends.

     ‘GPGME_KEYLIST_MODE_LOCATE_EXTERNAL’
          SINCE: 1.18.0

          This is a shortcut for the combination of
          ‘GPGME_KEYLIST_MODE_LOCATE’ and
          ‘GPGME_KEYLIST_MODE_FORCE_EXTERN’, which results in a
          ‘--locate-external-keys’ for ‘GPGME_PROTOCOL_OpenPGP’.

     At least one of ‘GPGME_KEYLIST_MODE_LOCAL’ and
     ‘GPGME_KEYLIST_MODE_EXTERN’ must be specified.  For future binary
     compatibility, you should get the current mode with
     ‘gpgme_get_keylist_mode’ and modify it by setting or clearing the
     appropriate bits, and then using that calculated value in the
     ‘gpgme_set_keylisting_mode’ operation.  This will leave all other
     bits in the mode value intact (in particular those that are not
     used in the current version of the library).

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the mode
     could be set correctly, and ‘GPG_ERR_INV_VALUE’ if CTX is not a
     valid pointer or MODE is not a valid mode.

 -- Function: gpgme_keylist_mode_t gpgme_get_keylist_mode
          (gpgme_ctx_t CTX)
     The function ‘gpgme_get_keylist_mode’ returns the current key
     listing mode of the context CTX.  This value can then be modified
     and used in a subsequent ‘gpgme_set_keylist_mode’ operation to only
     affect the desired bits (and leave all others intact).

     The function returns 0 if CTX is not a valid pointer, and the
     current mode otherwise.  Note that 0 is not a valid mode value.


File: gpgme.info,  Node: Passphrase Callback,  Next: Progress Meter Callback,  Prev: Key Listing Mode,  Up: Context Attributes

7.4.10 Passphrase Callback
--------------------------

 -- Data type: gpgme_error_t (*gpgme_passphrase_cb_t)(void *HOOK, const
          char *UID_HINT, const char *PASSPHRASE_INFO, int PREV_WAS_BAD,
          int FD)
     The ‘gpgme_passphrase_cb_t’ type is the type of functions usable as
     passphrase callback function.

     The argument UID_HINT might contain a string that gives an
     indication for which user ID the passphrase is required.  If this
     is not available, or not applicable (in the case of symmetric
     encryption, for example), UID_HINT will be ‘NULL’.

     The argument PASSPHRASE_INFO, if not ‘NULL’, will give further
     information about the context in which the passphrase is required.
     This information is engine and operation specific.

     If this is the repeated attempt to get the passphrase, because
     previous attempts failed, then PREV_WAS_BAD is 1, otherwise it will
     be 0.

     The user must write the passphrase, followed by a newline
     character, to the file descriptor FD.  The function
     ‘gpgme_io_writen’ should be used for the write operation.  Note
     that if the user returns 0 to indicate success, the user must at
     least write a newline character before returning from the callback.

     If an error occurs, return the corresponding ‘gpgme_error_t’ value.
     You can use the error code ‘GPG_ERR_CANCELED’ to abort the
     operation.  Otherwise, return ‘0’.

     Note: The passphrase_cb only works with GnuPG 1.x and 2.1.x and not
     with the 2.0.x series.  See ‘gpgme_set_pinentry_mode’ for more
     details on 2.1.x usage.

 -- Function: void gpgme_set_passphrase_cb (gpgme_ctx_t CTX,
          gpgme_passphrase_cb_t PASSFUNC, void *HOOK_VALUE)
     The function ‘gpgme_set_passphrase_cb’ sets the function that is
     used when a passphrase needs to be provided by the user to
     PASSFUNC.  The function PASSFUNC needs to implemented by the user,
     and whenever it is called, it is called with its first argument
     being HOOK_VALUE.  By default, no passphrase callback function is
     set.

     Not all crypto engines require this callback to retrieve the
     passphrase.  It is better if the engine retrieves the passphrase
     from a trusted agent (a daemon process), rather than having each
     user to implement their own passphrase query.  Some engines do not
     even support an external passphrase callback at all, in this case
     the error code ‘GPG_ERR_NOT_SUPPORTED’ is returned.

     For GnuPG >= 2.1 the pinentry mode has to be set to
     ‘GPGME_PINENTRY_MODE_LOOPBACK’ to enable the passphrase callback.
     See ‘gpgme_set_pinentry_mode’.

     The user can disable the use of a passphrase callback function by
     calling ‘gpgme_set_passphrase_cb’ with PASSFUNC being ‘NULL’.

 -- Function: void gpgme_get_passphrase_cb (gpgme_ctx_t CTX,
          gpgme_passphrase_cb_t *PASSFUNC, void **HOOK_VALUE)
     The function ‘gpgme_get_passphrase_cb’ returns the function that is
     used when a passphrase needs to be provided by the user in
     *PASSFUNC, and the first argument for this function in *HOOK_VALUE.
     If no passphrase callback is set, or CTX is not a valid pointer,
     ‘NULL’ is returned in both variables.

     PASSFUNC or HOOK_VALUE can be ‘NULL’.  In this case, the
     corresponding value will not be returned.


File: gpgme.info,  Node: Progress Meter Callback,  Next: Status Message Callback,  Prev: Passphrase Callback,  Up: Context Attributes

7.4.11 Progress Meter Callback
------------------------------

 -- Data type: void (*gpgme_progress_cb_t)(void *HOOK, const char *WHAT,
          int TYPE, int CURRENT, int TOTAL)
     The ‘gpgme_progress_cb_t’ type is the type of functions usable as
     progress callback function.

     The arguments are specific to the crypto engine.  More information
     about the progress information returned from the GnuPG engine can
     be found in the GnuPG source code in the file ‘doc/DETAILS’ in the
     section PROGRESS.

 -- Function: void gpgme_set_progress_cb (gpgme_ctx_t CTX,
          gpgme_progress_cb_t PROGFUNC, void *HOOK_VALUE)
     The function ‘gpgme_set_progress_cb’ sets the function that is used
     when progress information about a cryptographic operation is
     available.  The function PROGFUNC needs to implemented by the user,
     and whenever it is called, it is called with its first argument
     being HOOK_VALUE.  By default, no progress callback function is
     set.

     Setting a callback function allows an interactive program to
     display progress information about a long operation to the user.

     The user can disable the use of a progress callback function by
     calling ‘gpgme_set_progress_cb’ with PROGFUNC being ‘NULL’.

 -- Function: void gpgme_get_progress_cb (gpgme_ctx_t CTX,
          gpgme_progress_cb_t *PROGFUNC, void **HOOK_VALUE)
     The function ‘gpgme_get_progress_cb’ returns the function that is
     used to inform the user about the progress made in *PROGFUNC, and
     the first argument for this function in *HOOK_VALUE.  If no
     progress callback is set, or CTX is not a valid pointer, ‘NULL’ is
     returned in both variables.

     PROGFUNC or HOOK_VALUE can be ‘NULL’.  In this case, the
     corresponding value will not be returned.


File: gpgme.info,  Node: Status Message Callback,  Next: Context Flags,  Prev: Progress Meter Callback,  Up: Context Attributes

7.4.12 Status Message Callback
------------------------------

 -- Data type: gpgme_error_t (*gpgme_status_cb_t)(void *HOOK, const char
          *KEYWORD, const char *ARGS)
     The ‘gpgme_status_cb_t’ type is the type of function usable as a
     status message callback function.

     The argument KEYWORD is the name of the status message while the
     ARGS argument contains any arguments for the status message.

     If an error occurs, return the corresponding ‘gpgme_error_t’ value.
     Otherwise, return ‘0’.

 -- Function: void gpgme_set_status_cb (gpgme_ctx_t CTX,
          gpgme_status_cb_t STATUSFUNC, void *HOOK_VALUE)
     SINCE: 1.6.0

     The function ‘gpgme_set_status_cb’ sets the function that is used
     when a status message is received from gpg to STATUSFUNC.  The
     function STATUSFUNC needs to be implemented by the user, and
     whenever it is called, it is called with its first argument being
     HOOK_VALUE.  By default, no status message callback function is
     set.

     The user can disable the use of a status message callback function
     by calling ‘gpgme_set_status_cb’ with STATUSFUNC being ‘NULL’.

 -- Function: void gpgme_get_status_cb (gpgme_ctx_t CTX,
          gpgme_status_cb_t *STATUSFUNC, void **HOOK_VALUE)
     SINCE: 1.6.0

     The function ‘gpgme_get_status_cb’ returns the function that is
     used to process status messages from gpg in *STATUSFUNC, and the
     first argument for this function in *HOOK_VALUE.  If no status
     message callback is set, or CTX is not a valid pointer, ‘NULL’ is
     returned in both variables.


File: gpgme.info,  Node: Context Flags,  Next: Locale,  Prev: Status Message Callback,  Up: Context Attributes

7.4.13 Context Flags
--------------------

 -- Function: gpgme_error_t gpgme_set_ctx_flag (gpgme_ctx_t CTX,
          const char *NAME, const char *VALUE)

     SINCE: 1.7.0

     Some minor properties of the context can be controlled with flags
     set by this function.  The properties are identified by the
     following values for NAME:

     ‘"redraw"’
          This flag is normally not changed by the caller because GPGME
          sets and clears it automatically: The flag is cleared before
          an operation and set if an operation noticed that the engine
          has launched a Pinentry.  A Curses based application may use
          this information to redraw the screen; for example:

                   err = gpgme_op_keylist_start (ctx, "foo@example.org", 0);
                   while (!err)
                     {
                       err = gpgme_op_keylist_next (ctx, &key);
                       if (err)
                         break;
                       show_key (key);
                       gpgme_key_release (key);
                     }
                   if ((s = gpgme_get_ctx_flag (ctx, "redraw")) && *s)
                     redraw_screen ();
                   gpgme_release (ctx);

     ‘"full-status"’
          Using a VALUE of "1" the status callback set by
          gpgme_set_status_cb returns all status lines with the
          exception of PROGRESS lines.  With the default of "0" the
          status callback is only called in certain situations.

     ‘"raw-description"’
          Setting the VALUE to "1" returns human readable strings in a
          raw format.  For example the non breaking space characters
          ("~") will not be removed from the ‘description’ field of the
          ‘gpgme_tofu_info_t’ object.

     ‘"export-session-key"’
          Using a VALUE of "1" specifies that the context should try to
          export the symmetric session key when decrypting data.  By
          default, or when using an empty string or "0" for VALUE,
          session keys are not exported.

     ‘"override-session-key"’
          The string given in VALUE is passed to the GnuPG engine to
          override the session key for decryption.  The format of that
          session key is specific to GnuPG and can be retrieved during a
          decrypt operation when the context flag "export-session-key"
          is enabled.  Please be aware that using this feature with
          GnuPG < 2.1.16 or when decrypting an archive will leak the
          session key on many platforms via ps(1).

     ‘"auto-key-retrieve"’
          Setting the VALUE to "1" asks the backend to automatically
          retrieve a key for signature verification if possible.  Note
          that this option makes a "web bug" like behavior possible.
          Keyserver or Web Key Directory operators can see which keys
          you request, so by sending you a message signed by a brand new
          key (which you naturally will not have on your local keyring),
          the operator can tell both your IP address and the time when
          you verified the signature.

     ‘"auto-key-import"’
          Setting the VALUE to "1" forces the GPG backend to
          automatically import a missing key for signature verification
          from the signature.

     ‘"include-key-block"’
          Setting the VALUE to "1" forces the GPG backend to embed the
          signing key as well as an encryption subkey into the the
          signature.

     ‘"request-origin"’
          The string given in VALUE is passed to the GnuPG engines to
          request restrictions based on the origin of the request.
          Valid values are documented in the GnuPG manual and the gpg
          man page under the option ‘--request-origin’.  Requires at
          least GnuPG 2.2.6 to have an effect.

     ‘"no-symkey-cache"’
          For OpenPGP disable the passphrase cache used for symmetrical
          en- and decryption.  This cache is based on the message
          specific salt value.  Requires at least GnuPG 2.2.7 to have an
          effect.

     ‘"ignore-mdc-error"’
          This flag passes the option ‘--ignore-mdc-error’ to gpg.  This
          can be used to force decryption of a message which failed due
          to a missing integrity check.  This flag must be used with
          great caution and only if it is a known non-corrupted old
          message and the decryption result of the former try had the
          decryption result flag ‘legacy_cipher_nomdc’ set.  For
          failsafe reasons this flag is reset after each operation.

     ‘"auto-key-locate"’
          The string given in VALUE is passed to gpg.  This can be used
          to change the behavior of a ‘GPGME_KEYLIST_MODE_LOCATE’
          keylisting.  Valid values are documented in the GnuPG manual
          and the gpg man page under the option ‘--auto-key-locate’.
          Requires at least GnuPG 2.1.18.

          Note: Keys retrieved through ‘auto-key-locate’ are
          automatically imported in the keyring.

     ‘trust-model’
          SINCE: 1.11.2

          Change the trust-model for all GnuPG engine operations.  An
          empty string sets the trust-model back to the users default.
          If the trust-model is not supported by GnuPG the behavior is
          undefined and will likely cause all operations to fail.
          Example: "tofu+pgp".

          This options should be used carefully with a strict version
          requirement.  In some versions of GnuPG setting the
          trust-model changes the default trust-model for future
          operations.  A change in the trust-model also can have
          unintended side effects, like rebuilding the trust-db.

     ‘"extended-edit"’
          This flag passes the option ‘--expert’ to gpg key edit.  This
          can be used to get additional callbacks in ‘gpgme_op_edit’.

     ‘"cert-expire"’
          SINCE: 1.15.2 The string given in VALUE is passed to the GnuPG
          engine to set the expiration time to use for key signature
          expiration.  Valid values are documented in the GnuPG manual
          and the gpg man page under the option ‘--default-cert-expire’.

     ‘"key-origin"’
          SINCE: 1.16.1 The string given in VALUE is passed to the GnuPG
          engine to set the origin of imported keys.  Valid values are
          documented in the GnuPG manual and the gpg man page under the
          option ‘--key-origin’.

     ‘"import-filter"’
          SINCE: 1.16.1 The string given in VALUE is passed to the GnuPG
          engine to use as filter when importing keys.  Valid values are
          documented in the GnuPG manual and the gpg man page under the
          option ‘--import-filter’.

     ‘"import-options"’
          SINCE: 1.24.0 The string given in VALUE is passed to the GnuPG
          engine to use as options when importing keys.  Valid values
          are documented in the GnuPG manual and the gpg man page under
          the option ‘--import-options’.

     ‘"no-auto-check-trustdb"’
          SINCE: 1.19.0 Setting the VALUE to "1" forces the GPG backend
          to disable the automatic check of the trust database.

     ‘"proc-all-sigs"’
          SINCE: 1.24.0 Setting the VALUE to "1" forces the GPG backend
          not to stop signature checking of data after a bad signatures.
          This option is ignored if the backend itself does not support
          the –proc-all-sigs option.

     ‘"known-notations"’
          SINCE: 1.24.0 The VALUE is a space or comma delimited list of
          notation names which will be used to create ‘--known-notation’
          options for gpg.

     This function returns ‘0’ on success.

 -- Function: const char * gpgme_get_ctx_flag (gpgme_ctx_t CTX,
          const char *NAME)

     SINCE: 1.8.0

     The value of flags settable by ‘gpgme_set_ctx_flag’ can be
     retrieved by this function.  If NAME is unknown the function
     returns ‘NULL’.  For boolean flags an empty string is returned for
     False and the string "1" is returned for True; either atoi(3) or a
     test for an empty string can be used to get the boolean value.


File: gpgme.info,  Node: Locale,  Next: Additional Logs,  Prev: Context Flags,  Up: Context Attributes

7.4.14 Locale
-------------

A locale setting can be associated with a context.  This locale is
passed to the crypto engine, and used for applications like the PIN
entry, which is displayed to the user when entering a passphrase is
required.

   The default locale is used to initialize the locale setting of all
contexts created afterwards.

 -- Function: gpgme_error_t gpgme_set_locale (gpgme_ctx_t CTX,
          int CATEGORY, const char *VALUE)
     SINCE: 0.4.3

     The function ‘gpgme_set_locale’ sets the locale of the context CTX,
     or the default locale if CTX is a null pointer.

     The locale settings that should be changed are specified by
     CATEGORY.  Supported categories are ‘LC_CTYPE’, ‘LC_MESSAGES’, and
     ‘LC_ALL’, which is a wildcard you can use if you want to change all
     the categories at once.

     The value to be used for the locale setting is VALUE, which will be
     copied to GPGME’s internal data structures.  VALUE can be a null
     pointer, which disables setting the locale, and will make PIN entry
     and other applications use their default setting, which is usually
     not what you want.

     Note that the settings are only used if the application runs on a
     text terminal, and that the settings should fit the configuration
     of the output terminal.  Normally, it is sufficient to initialize
     the default value at startup.

     The function returns an error if not enough memory is available.


File: gpgme.info,  Node: Additional Logs,  Prev: Locale,  Up: Context Attributes

7.4.15 Additional Logs
----------------------

Additional logs can be associated with a context.  These logs are engine
specific and can be be obtained with ‘gpgme_op_getauditlog’.

 -- Function: gpgme_error_t gpgme_op_getauditlog (gpgme_ctx_t CTX,
          gpgme_data_t OUTPUT, unsigned int FLAGS)
     SINCE: 1.1.1

     The function ‘gpgme_op_getauditlog’ is used to obtain additional
     logs as specified by FLAGS into the OUTPUT data.  If

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if a log
     could be queried from the engine, and ‘GPG_ERR_NOT_IMPLEMENTED’ if
     the log specified in FLAGS is not available for this engine.  If no
     log is available ‘GPG_ERR_NO_DATA’ is returned.

     The value in FLAGS is a bitwise-or combination of one or multiple
     of the following bit values:

     ‘GPGME_AUDITLOG_DIAG’
          SINCE: 1.11.2

          Obtain diagnostic output which would be written to ‘stderr’ in
          interactive use of the engine.  This can be used to provide
          additional diagnostic information in case of errors in other
          operations.

          Note: If log-file has been set in the configuration the log
          will be empty and ‘GPG_ERR_NO_DATA’ will be returned.

          Implemented for: ‘GPGME_PROTOCOL_OpenPGP’

     ‘GPGME_AUDITLOG_DEFAULT’
          SINCE: 1.11.2

          This flag has the value 0 for compatibility reasons.  Obtains
          additional information from the engine by issuing the
          ‘GETAUDITLOG’ command.  For ‘GPGME_PROTOCOL_CMS’ this provides
          additional information about the X509 certificate chain.

          Implemented for: ‘GPGME_PROTOCOL_CMS’

     ‘GPGME_AUDITLOG_HTML’
          SINCE: 1.1.1

          Same as ‘GPGME_AUDITLOG_DEFAULT’ but in HTML.

          Implemented for: ‘GPGME_PROTOCOL_CMS’

 -- Function: gpgme_error_t gpgme_op_getauditlog_start (gpgme_ctx_t CTX,
          gpgme_data_t OUTPUT, unsigned int FLAGS)
     SINCE: 1.1.1

     This is the asynchronous variant of ‘gpgme_op_getauditlog’.


File: gpgme.info,  Node: Key Management,  Next: Crypto Operations,  Prev: Context Attributes,  Up: Contexts

7.5 Key Management
==================

Some of the cryptographic operations require that recipients or signers
are specified.  This is always done by specifying the respective keys
that should be used for the operation.  The following section describes
how such keys can be selected and manipulated.

* Menu:

* Key objects::                   Description of the key structures.
* Listing Keys::                  Browsing the list of available keys.
* Information About Keys::        Requesting detailed information about keys.
* Manipulating Keys::             Operations on keys.
* Generating Keys::               Creating new key pairs.
* Signing Keys::                  Adding key signatures to public keys.
* Exporting Keys::                Retrieving key data from the key ring.
* Importing Keys::                Adding keys to the key ring.
* Deleting Keys::                 Removing keys from the key ring.
* Changing Passphrases::          Change the passphrase of a key.
* Changing TOFU Data::            Changing data pertaining to TOFU.
* Advanced Key Editing::          Advanced key edit operation.


File: gpgme.info,  Node: Key objects,  Next: Listing Keys,  Up: Key Management

7.5.1 Key objects
-----------------

The keys are represented in GPGME by structures which may only be read
by the application but never be allocated or changed.  They are valid as
long as the key object itself is valid.

 -- Data type: gpgme_key_t

     The ‘gpgme_key_t’ type is a pointer to a key object.  It has the
     following members:

     ‘gpgme_keylist_mode_t keylist_mode’
          SINCE: 0.9.0

          The keylist mode that was active when the key was retrieved.

     ‘unsigned int revoked : 1’
          This is true if the key is revoked.

     ‘unsigned int expired : 1’
          This is true if the key is expired.

     ‘unsigned int disabled : 1’
          This is true if the key is disabled.

     ‘unsigned int invalid : 1’
          This is true if the key is invalid.  This might have several
          reasons, for a example for the S/MIME backend, it will be set
          during key listings if the key could not be validated due to
          missing certificates or unmatched policies.

     ‘unsigned int can_encrypt : 1’
          This is true if the key or one of its subkeys can be used for
          encryption and the encryption will likely succeed.

     ‘unsigned int can_sign : 1’
          This is true if the key or one of its subkeys can be used to
          create data signatures and the signing will likely succeed.

     ‘unsigned int can_certify : 1’
          This is true if the key or one of its subkeys can be used to
          create key certificates.

     ‘unsigned int can_authenticate : 1’
          SINCE: 0.4.5

          This is true if the key (ie one of its subkeys) can be used
          for authentication and the authentication will likely succeed.

     ‘unsigned int has_encrypt : 1’
          SINCE: 1.23.0

          This is true if the key or one of its subkeys is capable of
          encryption.  Note that this flag is set even if the key is
          expired.

     ‘unsigned int has_sign : 1’
          SINCE: 1.23.0

          This is true if the key or one of its subkeys is capable of
          signing.  Note that this flag is set even if the key is
          expired.

     ‘unsigned int has_certify : 1’
          SINCE: 1.23.0

          This is true if the key or one of its subkeys is capable of
          certification.  Note that this flag is set even if the key is
          expired.

     ‘unsigned int has_authenticate : 1’
          SINCE: 1.23.0

          This is true if the key or one of its subkeys is capable of
          authentication.  Note that this flag is set even if the key is
          expired.

     ‘unsigned int is_qualified : 1’
          SINCE: 1.1.0

          This is true if the key can be used for qualified signatures
          according to local government regulations.

     ‘unsigned int secret : 1’
          This is true if the key is a secret key.  Note, that this will
          always be true even if the corresponding subkey flag may be
          false (offline/stub keys).  This is only set if a listing of
          secret keys has been requested or if
          ‘GPGME_KEYLIST_MODE_WITH_SECRET’ is active.

     ‘unsigned int origin : 5’
          SINCE: 1.8.0

          Reserved for the origin of this key.

     ‘gpgme_protocol_t protocol’
          This is the protocol supported by this key.

     ‘char *issuer_serial’
          If ‘protocol’ is ‘GPGME_PROTOCOL_CMS’, then this is the issuer
          serial.

     ‘char *issuer_name’
          If ‘protocol’ is ‘GPGME_PROTOCOL_CMS’, then this is the issuer
          name.

     ‘char *chain_id’
          If ‘protocol’ is ‘GPGME_PROTOCOL_CMS’, then this is the chain
          ID, which can be used to built the certificate chain.

     ‘gpgme_validity_t owner_trust’
          If ‘protocol’ is ‘GPGME_PROTOCOL_OpenPGP’, then this is the
          owner trust.

     ‘gpgme_subkey_t subkeys’
          This is a linked list with the subkeys of the key.  The first
          subkey in the list is the primary key and usually available.

     ‘gpgme_user_id_t uids’
          This is a linked list with the user IDs of the key.  The first
          user ID in the list is the main (or primary) user ID.

     ‘char *fpr’
          SINCE: 1.7.0

          This field gives the fingerprint of the primary key.  Note
          that this is a copy of the fingerprint of the first subkey.
          For an incomplete key (for example from a verification result)
          a subkey may be missing but this field may be set
          nevertheless.

     ‘unsigned long last_update’
          SINCE: 1.8.0

          Reserved for the time of the last update of this key.

     ‘gpgme_revocation_key_t revkeys’
          SINCE: 1.24.0 This is a linked list with the revocation keys
          for the key.

 -- Data type: gpgme_subkey_t
     SINCE: 1.5.0

     The ‘gpgme_subkey_t’ type is a pointer to a subkey structure.
     Subkeys are one component of a ‘gpgme_key_t’ object.  In fact,
     subkeys are those parts that contains the real information about
     the individual cryptographic keys that belong to the same key
     object.  One ‘gpgme_key_t’ can contain several subkeys.  The first
     subkey in the linked list is also called the primary key.

     The subkey structure has the following members:

     ‘gpgme_subkey_t next’
          This is a pointer to the next subkey structure in the linked
          list, or ‘NULL’ if this is the last element.

     ‘unsigned int revoked : 1’
          This is true if the subkey is revoked.

     ‘unsigned int expired : 1’
          This is true if the subkey is expired.

     ‘unsigned int disabled : 1’
          This is true if the subkey is disabled.

     ‘unsigned int invalid : 1’
          This is true if the subkey is invalid.

     ‘unsigned int can_encrypt : 1’
          This is true if the subkey can be used for encryption.

     ‘unsigned int can_sign : 1’
          This is true if the subkey can be used to create data
          signatures.

     ‘unsigned int can_certify : 1’
          This is true if the subkey can be used to create key
          certificates.

     ‘unsigned int can_authenticate : 1’
          SINCE: 0.4.5

          This is true if the subkey can be used for authentication.

     ‘unsigned int is_qualified : 1’
          SINCE: 1.1.0

          This is true if the subkey can be used for qualified
          signatures according to local government regulations.

     ‘unsigned int is_de_vs : 1’
          SINCE: 1.8.0

          This is true if the subkey complies with the rules for
          classified information in Germany at the restricted level
          (VS-NfD). This are currently RSA keys of at least 3072 bits or
          ECDH/ECDSA keys using a Brainpool curve.

     ‘unsigned int beta_compliance : 1;’
          SINCE: 1.24.0 The compliance flags (e.g.  is_de_vs) are set
          but the software has not yet been approved or is in a beta
          state.

     ‘unsigned int secret : 1’
          This is true if the subkey is a secret key.  Note that it will
          be false if the key is actually a stub key; i.e., a secret key
          operation is currently not possible (offline-key).  This is
          only set if a listing of secret keys has been requested or if
          ‘GPGME_KEYLIST_MODE_WITH_SECRET’ is active.

     ‘gpgme_pubkey_algo_t pubkey_algo’
          This is the public key algorithm supported by this subkey.

     ‘unsigned int length’
          This is the length of the subkey (in bits).

     ‘char *keyid’
          This is the key ID of the subkey in hexadecimal digits.

     ‘char *fpr’
          This is the fingerprint of the subkey in hexadecimal digits,
          if available.

     ‘char *v5fpr’
          For a v4 OpenPGP key this is its v5 style fingerprint of the
          subkey in hexadecimal digits, if available.

     ‘char *keygrip’
          SINCE: 1.7.0

          The keygrip of the subkey in hex digit form or ‘NULL’ if not
          available.

     ‘long int timestamp’
          This is the creation timestamp of the subkey.  This is -1 if
          the timestamp is invalid, and 0 if it is not available.

     ‘long int expires’
          This is the expiration timestamp of the subkey, or 0 if the
          subkey does not expire.

     ‘unsigned int is_cardkey : 1’
          SINCE: 1.2.0

          True if the secret key is stored on a smart card.

     ‘char *card_number’
          SINCE: 1.2.0

          The serial number of a smart card holding this key or ‘NULL’.

     ‘char *curve’
          For ECC algorithms the name of the curve.

 -- Data type: gpgme_user_id_t

     A user ID is a component of a ‘gpgme_key_t’ object.  One key can
     have many user IDs.  The first one in the list is the main (or
     primary) user ID.

     The user ID structure has the following members.

     ‘gpgme_user_id_t next’
          This is a pointer to the next user ID structure in the linked
          list, or ‘NULL’ if this is the last element.

     ‘unsigned int revoked : 1’
          This is true if the user ID is revoked.

     ‘unsigned int invalid : 1’
          This is true if the user ID is invalid.

     ‘gpgme_validity_t validity’
          This specifies the validity of the user ID.

     ‘char *uid’
          This is the user ID string.

     ‘char *name’
          This is the name component of ‘uid’, if available.

     ‘char *comment’
          This is the comment component of ‘uid’, if available.

     ‘char *email’
          This is the email component of ‘uid’, if available.

     ‘char *address;’
          The mail address (addr-spec from RFC-5322) of the user ID
          string.  This is general the same as the ‘email’ part of this
          structure but might be slightly different.  If no mail address
          is available ‘NULL’ is stored.

     ‘gpgme_tofu_info_t tofu’
          SINCE: 1.7.0

          If not ‘NULL’ information from the TOFU database pertaining to
          this user id.

     ‘gpgme_key_sig_t signatures’
          This is a linked list with the signatures on this user ID.

     ‘unsigned int origin : 5’
          SINCE: 1.8.0

          Reserved for the origin of this user ID.

     ‘unsigned long last_update’
          SINCE: 1.8.0

          Reserved for the time of the last update of this user ID.

     ‘char *uidhash;’
          A string used by gpg to identify a user ID. This string can be
          used at certain prompts of ‘gpgme_op_edit’ to select a user
          ID. Users must be prepared to see a ‘NULL’ value here.  The
          format of the value is not specified and may depend on the
          GPGME or GnuPG version.

 -- Data type: gpgme_tofu_info_t

     SINCE: 1.7.0

     The ‘gpgme_tofu_info_t’ type is a pointer to a tofu info structure.
     Tofu info structures are one component of a ‘gpgme_user_id_t’
     object, and provide information from the TOFU database pertaining
     to the user ID.

     The tofu info structure has the following members:

     ‘gpgme_tofu_info_t next’
          This is a pointer to the next tofu info structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘unsigned int validity : 3’
          This is the TOFU validity.  It can have the following values:

          ‘0’
               The value ‘0’ indicates a conflict.

          ‘1’
               The value ‘1’ indicates a key without history.

          ‘2’
               The value ‘2’ indicates a key with too little history.

          ‘3’
               The value ‘3’ indicates a key with enough history for
               basic trust.

          ‘4’
               The value ‘4’ indicates a key with a lot of history.

     ‘unsigned int policy : 4’
          This is the TOFU policy, see ‘gpgme_tofu_policy_t’.

     ‘unsigned short signcount’
          This is the number of signatures seen for this binding (or
          ‘USHRT_MAX’ if there are more than that).

     ‘unsigned short encrcount’
          This is the number of encryptions done with this binding (or
          ‘USHRT_MAX’ if there are more than that).

     ‘unsigned long signfirst’
          Number of seconds since Epoch when the first signature was
          seen with this binding.

     ‘unsigned long signlast’
          Number of seconds since Epoch when the last signature was seen
          with this binding.

     ‘unsigned long encrfirst’
          Number of seconds since Epoch when the first encryption was
          done with this binding.

     ‘unsigned long encrlast’
          Number of seconds since Epoch when the last encryption was
          done with this binding.

     ‘char *description’
          A human-readable string summarizing the TOFU data (or NULL).

 -- Data type: gpgme_key_sig_t

     The ‘gpgme_key_sig_t’ type is a pointer to a key signature
     structure.  Key signatures are one component of a ‘gpgme_key_t’
     object, and validate user IDs on the key in the OpenPGP protocol.

     The signatures on a key are only available if the key was retrieved
     via a listing operation with the ‘GPGME_KEYLIST_MODE_SIGS’ mode
     enabled, because it can be expensive to retrieve all signatures of
     a key.

     The signature notations on a key signature are only available if
     the key was retrieved via a listing operation with the
     ‘GPGME_KEYLIST_MODE_SIG_NOTATIONS’ mode enabled, because it can be
     expensive to retrieve all signature notations.

     The key signature structure has the following members:

     ‘gpgme_key_sig_t next’
          This is a pointer to the next key signature structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘unsigned int revoked : 1’
          This is true if the key signature is a revocation signature.

     ‘unsigned int expired : 1’
          This is true if the key signature is expired.

     ‘unsigned int invalid : 1’
          This is true if the key signature is invalid.

     ‘unsigned int exportable : 1’
          This is true if the key signature is exportable.

     ‘unsigned int trust_depth : 8’
          This is the depth of a trust signature, or 0 if the key
          signature is not a trust signature.

     ‘unsigned int trust_value : 8’
          This is the trust amount of a trust signature.

     ‘gpgme_pubkey_algo_t pubkey_algo’
          This is the public key algorithm used to create the signature.

     ‘char *keyid’
          This is the key ID of the key (in hexadecimal digits) used to
          create the signature.

     ‘long int timestamp’
          This is the creation timestamp of the key signature.  This is
          -1 if the timestamp is invalid, and 0 if it is not available.

     ‘long int expires’
          This is the expiration timestamp of the key signature, or 0 if
          the key signature does not expire.

     ‘char *trust_scope’
          This is a regular expression that limits the scope of a trust
          signature.  Users must be prepared to see a ‘NULL’ value here.

     ‘gpgme_error_t status’
          This is the status of the signature and has the same meaning
          as the member of the same name in a ‘gpgme_signature_t’
          object.

     ‘unsigned int sig_class’
          This specifies the signature class of the key signature.  The
          meaning is specific to the crypto engine.

     ‘char *uid’
          This is the main user ID of the key used to create the
          signature.

     ‘char *name’
          This is the name component of ‘uid’, if available.

     ‘char *comment’
          This is the comment component of ‘uid’, if available.

     ‘char *email’
          This is the email component of ‘uid’, if available.

     ‘gpgme_sig_notation_t notations’
          This is a linked list with the notation data and policy URLs.

 -- Data type: gpgme_revocation_key_t
     SINCE: 1.24.0

     The ‘gpgme_revocation_key_t’ type is a pointer to a revocation key
     structure.  Revocation key structures are one component of a
     ‘gpgme_key_t’ object.  They provide information about the
     designated revocation keys for a key.

     The revocation key structure has the following members:

     ‘gpgme_revocation_key_t next’
          This is a pointer to the next revocation key structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘gpgme_pubkey_algo_t pubkey_algo’
          This is the public key algorithm of the revocation key.

     ‘char *fpr’
          This is the fingerprint of the revocation_key in hexadecimal
          digits.

     ‘unsigned int key_class’
          This is the class of the revocation key signature subpacket.

     ‘unsigned int sensitive : 1’
          This is true if the revocation key is marked as sensitive.


File: gpgme.info,  Node: Listing Keys,  Next: Information About Keys,  Prev: Key objects,  Up: Key Management

7.5.2 Listing Keys
------------------

 -- Function: gpgme_error_t gpgme_op_keylist_start (gpgme_ctx_t CTX,
          const char *PATTERN, int SECRET_ONLY)

     The function ‘gpgme_op_keylist_start’ initiates a key listing
     operation inside the context CTX.  It sets everything up so that
     subsequent invocations of ‘gpgme_op_keylist_next’ return the keys
     in the list.

     If PATTERN is ‘NULL’, all available keys are returned.  Otherwise,
     PATTERN contains an engine specific expression that is used to
     limit the list to all keys matching the pattern.  Note that the
     total length of the pattern is restricted to an engine-specific
     maximum (a couple of hundred characters are usually accepted).  The
     pattern should be used to restrict the search to a certain common
     name or user, not to list many specific keys at once by listing
     their fingerprints or key IDs.

     If SECRET_ONLY is not ‘0’, the list is restricted to secret keys
     only.

     The context will be busy until either all keys are received (and
     ‘gpgme_op_keylist_next’ returns ‘GPG_ERR_EOF’), or
     ‘gpgme_op_keylist_end’ is called to finish the operation.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if CTX is
     not a valid pointer, and passes through any errors that are
     reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_keylist_ext_start (gpgme_ctx_t CTX,
          const char *PATTERN[], int SECRET_ONLY, int RESERVED)

     The function ‘gpgme_op_keylist_ext_start’ initiates an extended key
     listing operation inside the context CTX.  It sets everything up so
     that subsequent invocations of ‘gpgme_op_keylist_next’ return the
     keys in the list.

     If PATTERN or *PATTERN is ‘NULL’, all available keys are returned.
     Otherwise, PATTERN is a ‘NULL’ terminated array of strings that are
     used to limit the list to all keys matching at least one of the
     patterns verbatim.  Note that the total length of all patterns is
     restricted to an engine-specific maximum (the exact limit also
     depends on the number of patterns and amount of quoting required,
     but a couple of hundred characters are usually accepted).  Patterns
     should be used to restrict the search to a certain common name or
     user, not to list many specific keys at once by listing their
     fingerprints or key IDs.

     If SECRET_ONLY is not ‘0’, the list is restricted to secret keys
     only.

     The value of RESERVED must be ‘0’.

     The context will be busy until either all keys are received (and
     ‘gpgme_op_keylist_next’ returns ‘GPG_ERR_EOF’), or
     ‘gpgme_op_keylist_end’ is called to finish the operation.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if CTX is
     not a valid pointer, and passes through any errors that are
     reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_keylist_from_data_start
          (gpgme_ctx_t CTX, gpgme_data_t DATA, int RESERVED)

     SINCE: 1.8.0

     The function ‘gpgme_op_keylist_from_data_start’ initiates a key
     listing operation inside the context CTX.  In contrast to the other
     key listing operation the keys are read from the supplied DATA and
     not from the local key database.  The keys are also not imported
     into the local key database.  The function sets everything up so
     that subsequent invocations of ‘gpgme_op_keylist_next’ return the
     keys from DATA.

     The value of RESERVED must be ‘0’.

     This function requires at least GnuPG version 2.1.14 and currently
     works only with OpenPGP keys.

     The context will be busy until either all keys are received (and
     ‘gpgme_op_keylist_next’ returns ‘GPG_ERR_EOF’), or
     ‘gpgme_op_keylist_end’ is called to finish the operation.  While
     the context is busy DATA may not be released.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if CTX is
     not a valid pointer, and passes through any errors that are
     reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_keylist_next (gpgme_ctx_t CTX,
          gpgme_key_t *R_KEY)

     The function ‘gpgme_op_keylist_next’ returns the next key in the
     list created by a previous ‘gpgme_op_keylist_start’ operation in
     the context CTX.  The key will have one reference for the user.
     *Note Manipulating Keys::.

     This is the only way to get at ‘gpgme_key_t’ objects in GPGME.

     If the last key in the list has already been returned,
     ‘gpgme_op_keylist_next’ returns ‘GPG_ERR_EOF’.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if CTX or
     R_KEY is not a valid pointer, and ‘GPG_ERR_ENOMEM’ if there is not
     enough memory for the operation.

 -- Function: gpgme_error_t gpgme_op_keylist_end (gpgme_ctx_t CTX)

     The function ‘gpgme_op_keylist_end’ ends a pending key list
     operation in the context CTX.

     After the operation completed successfully, the result of the key
     listing operation can be retrieved with ‘gpgme_op_keylist_result’.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if CTX is
     not a valid pointer, and ‘GPG_ERR_ENOMEM’ if at some time during
     the operation there was not enough memory available.

   The following example illustrates how all keys containing a certain
string (‘g10code’) can be listed with their key ID and the name and
email address of the main user ID:

     gpgme_ctx_t ctx;
     gpgme_key_t key;
     gpgme_error_t err = gpgme_new (&ctx);

     if (!err)
       {
         err = gpgme_op_keylist_start (ctx, "g10code", 0);
         while (!err)
           {
             err = gpgme_op_keylist_next (ctx, &key);
             if (err)
               break;
             printf ("%s:", key->subkeys->keyid);
             if (key->uids && key->uids->name)
               printf (" %s", key->uids->name);
             if (key->uids && key->uids->email)
               printf (" <%s>", key->uids->email);
             putchar ('\n');
             gpgme_key_release (key);
           }
         gpgme_release (ctx);
       }
     if (gpg_err_code (err) != GPG_ERR_EOF)
       {
         fprintf (stderr, "can not list keys: %s\n", gpgme_strerror (err));
         exit (1);
       }

 -- Data type: gpgme_keylist_result_t
     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_keylist_*’ operation.  After successfully ending a key
     listing operation, you can retrieve the pointer to the result with
     ‘gpgme_op_keylist_result’.  The structure contains the following
     member:

     ‘unsigned int truncated : 1’
          This is true if the crypto backend had to truncate the result,
          and less than the desired keys could be listed.

 -- Function: gpgme_keylist_result_t gpgme_op_keylist_result
          (gpgme_ctx_t CTX)
     The function ‘gpgme_op_keylist_result’ returns a
     ‘gpgme_keylist_result_t’ pointer to a structure holding the result
     of a ‘gpgme_op_keylist_*’ operation.  The pointer is only valid if
     the last operation on the context was a key listing operation, and
     if this operation finished successfully.  The returned pointer is
     only valid until the next operation is started on the context.

   In a simple program, for which a blocking operation is acceptable,
the following function can be used to retrieve a single key.

 -- Function: gpgme_error_t gpgme_get_key (gpgme_ctx_t CTX,
          const char *FPR, gpgme_key_t *R_KEY, int SECRET)
     The function ‘gpgme_get_key’ gets the key with the fingerprint (or
     key ID) FPR from the crypto backend and return it in R_KEY.  If
     SECRET is true, get the secret key.  The currently active keylist
     mode is used to retrieve the key.  The key will have one reference
     for the user.

     If the key is not found in the keyring, ‘gpgme_get_key’ returns the
     error code ‘GPG_ERR_EOF’ and *R_KEY will be set to ‘NULL’.

     The function returns the error code ‘GPG_ERR_INV_VALUE’ if CTX or
     R_KEY is not a valid pointer or FPR is not a fingerprint or key ID,
     ‘GPG_ERR_AMBIGUOUS_NAME’ if the key ID was not a unique specifier
     for a key, and ‘GPG_ERR_ENOMEM’ if at some time during the
     operation there was not enough memory available.


File: gpgme.info,  Node: Information About Keys,  Next: Manipulating Keys,  Prev: Listing Keys,  Up: Key Management

7.5.3 Information About Keys
----------------------------

Please see the beginning of this section for more information about
‘gpgme_key_t’ objects.

 -- Data type: gpgme_validity_t
     The ‘gpgme_validity_t’ type is used to specify the validity of a
     user ID in a key.  The following validities are defined:

     ‘GPGME_VALIDITY_UNKNOWN’
          The user ID is of unknown validity.  The string representation
          of this validity is “?”.

     ‘GPGME_VALIDITY_UNDEFINED’
          The validity of the user ID is undefined.  The string
          representation of this validity is “q”.

     ‘GPGME_VALIDITY_NEVER’
          The user ID is never valid.  The string representation of this
          validity is “n”.

     ‘GPGME_VALIDITY_MARGINAL’
          The user ID is marginally valid.  The string representation of
          this validity is “m”.

     ‘GPGME_VALIDITY_FULL’
          The user ID is fully valid.  The string representation of this
          validity is “f”.

     ‘GPGME_VALIDITY_ULTIMATE’
          The user ID is ultimately valid.  The string representation of
          this validity is “u”.


File: gpgme.info,  Node: Manipulating Keys,  Next: Generating Keys,  Prev: Information About Keys,  Up: Key Management

7.5.4 Manipulating Keys
-----------------------

 -- Function: void gpgme_key_ref (gpgme_key_t KEY)
     The function ‘gpgme_key_ref’ acquires an additional reference for
     the key KEY.

 -- Function: void gpgme_key_unref (gpgme_key_t KEY)
     The function ‘gpgme_key_unref’ releases a reference for the key
     KEY.  If this was the last reference, the key will be destroyed and
     all resources associated to it will be released.

 -- Function: gpgme_error_t gpgme_op_setexpire (gpgme_ctx_t CTX,
          gpgme_key_t KEY, unsigned long EXPIRES, const char *SUBFPRS,
          unsigned int RESERVED);

     SINCE: 1.14.1

     The function ‘gpgme_op_setexpire’ sets the expiration time of the
     key KEY or of the specified subkeys.  This function requires at
     least version 2.1.22 of GnuPG.

     KEY specifies the key to operate on.

     EXPIRES specifies the expiration time in seconds from now.  To be
     similar to other usages where expiration times are provided in
     unsigned long this is similar to the key creation date and so it is
     in seconds from NOW.

     The common case is to use 0 to not set an expiration time.  Note
     that this parameter takes an unsigned long value and not a ‘time_t’
     to avoid problems on systems which use a signed 32 bit ‘time_t’.
     Note further that the OpenPGP protocol uses 32 bit values for
     timestamps and thus can only encode dates up to the year 2106.

     SUBFPRS selects the subkey(s) for which the expiration time should
     be set.  If SUBFPRS is set to ‘NULL’, then the expiration time of
     the primary key is set.  If SUBFPRS is an asterisk (‘*’), then the
     expiration times of all non-revoked and not yet expired subkeys are
     set.  To select more than one subkey put all subkey fingerprints
     into one string separated by linefeeds characters (‘\n’).

     RESERVED is reserved for later use and must be ‘0’.

 -- Function: gpgme_error_t gpgme_op_setexpire_start (gpgme_ctx_t CTX,
          gpgme_key_t KEY, unsigned long EXPIRES, const char *SUBFPRS,
          unsigned int FLAGS);

     SINCE: 1.14.1

     The function ‘gpgme_op_setexpire_start’ initiates a
     ‘gpgme_op_setexpire’ operation; see there for details.  It must be
     completed by calling ‘gpgme_wait’ on the context.  *Note Waiting
     For Completion::.

 -- Function: gpgme_error_t gpgme_op_setownertrust (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *VALUE);

     SINCE: 1.24.0

     The function ‘gpgme_op_setownertrust’ sets the owner trust of the
     key KEY or it sets the disable flag of the key KEY.  This function
     only works for OpenPGP and requires at least version 2.4.6 of
     GnuPG.

     KEY specifies the key to operate on.

     VALUE specifies the owner trust value to set.  Valid values are
     "undefined", "never", "marginal", "full", "ultimate".  If VALUE is
     the string "disable" then the key KEY is disabled.  If VALUE is the
     string "enable" then the key KEY is re-enabled.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation was completed successfully, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, and ‘GPG_ERR_INV_VALUE’ if
     KEY is not a valid pointer or not a valid key or if VALUE is not a
     valid pointer or the empty string.

 -- Function: gpgme_error_t gpgme_op_setownertrust_start
          (gpgme_ctx_t CTX, gpgme_key_t KEY, const char *VALUE);

     SINCE: 1.24.0

     The function ‘gpgme_op_setownertrust_start’ initiates a
     ‘gpgme_op_setownertrust’ operation; see there for details.  It must
     be completed by calling ‘gpgme_wait’ on the context.  *Note Waiting
     For Completion::.

     The function returns the same error codes as
     ‘gpgme_op_setownertrust’.


File: gpgme.info,  Node: Generating Keys,  Next: Signing Keys,  Prev: Manipulating Keys,  Up: Key Management

7.5.5 Generating Keys
---------------------

GPGME provides a set of functions to create public key pairs.  Most of
these functions require the use of GnuPG 2.1 and later; for older GnuPG
versions the ‘gpgme_op_genkey’ function can be used.  Existing code
which wants to update to the new functions or new code which shall
supports older GnuPG versions may try the new functions first and
provide a fallback to the old function if the error code
‘GPG_ERR_NOT_SUPPORTED’ is received.

 -- Function: gpgme_error_t gpgme_op_createkey (gpgme_ctx_t CTX,
          const char *USERID, const char *ALGO, unsigned long RESERVED,
          unsigned long EXPIRES, gpgme_key_t EXTRAKEY,
          unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_createkey’ generates a new key for the
     procotol active in the context CTX.  As of now this function does
     only work for OpenPGP and requires at least version 2.1.13 of
     GnuPG.

     USERID is commonly the mail address associated with the key.  GPGME
     does not require a specific syntax but if more than a mail address
     is given, RFC-822 style format is suggested.  The value is expected
     to be in UTF-8 encoding (i.e., no IDN encoding for mail addresses).
     This is a required parameter.

     ALGO specifies the algorithm for the new key (actually a keypair of
     public and private key).  For a list of supported algorithms, see
     the GnuPG manual.  If ALGO is ‘NULL’ or the string "default", the
     key is generated using the default algorithm of the engine.  If the
     string "future-default" is used the engine may use an algorithm
     which is planned to be the default in a future release of the
     engine; however existing implementation of the protocol may not be
     able to already handle such future algorithms.  For the OpenPGP
     protocol, the specification of a default algorithm, without
     requesting a non-default usage via FLAGS, triggers the creation of
     a primary key plus a secondary key (subkey).

     RESERVED must be set to zero.

     EXPIRES specifies the expiration time in seconds.  If you supply 0,
     a reasonable expiration time is chosen.  Use the flag
     ‘GPGME_CREATE_NOEXPIRE’ to create keys that do not expire.  Note
     that this parameter takes an unsigned long value and not a ‘time_t’
     to avoid problems on systems which use a signed 32 bit ‘time_t’.
     Note further that the OpenPGP protocol uses 32 bit values for
     timestamps and thus can only encode dates up to the year 2106.

     EXTRAKEY is currently not used and must be set to ‘NULL’.  A future
     version of GPGME may use this parameter to create X.509 keys.

     FLAGS can be set to the bit-wise OR of the following flags:

     ‘GPGME_CREATE_SIGN’
     ‘GPGME_CREATE_ENCR’
     ‘GPGME_CREATE_CERT’
     ‘GPGME_CREATE_AUTH’
          SINCE: 1.7.0

          Do not create the key with the default capabilities (key
          usage) of the requested algorithm but use those explicitly
          given by these flags: “signing”, “encryption”,
          “certification”, or “authentication”.  The allowed
          combinations depend on the algorithm.

          If any of these flags are set and a default algorithm has been
          selected only one key is created in the case of the OpenPGP
          protocol.

     ‘GPGME_CREATE_NOPASSWD’
          SINCE: 1.7.0

          Request generation of the key without password protection.

     ‘GPGME_CREATE_SELFSIGNED’
          SINCE: 1.7.0

          For an X.509 key do not create a CSR but a self-signed
          certificate.  This has not yet been implemented.

     ‘GPGME_CREATE_NOSTORE’
          SINCE: 1.7.0

          Do not store the created key in the local key database.  This
          has not yet been implemented.

     ‘GPGME_CREATE_WANTPUB’
     ‘GPGME_CREATE_WANTSEC’
          SINCE: 1.7.0

          Return the public or secret key as part of the result
          structure.  This has not yet been implemented.

     ‘GPGME_CREATE_FORCE’
          SINCE: 1.7.0

          The engine does not allow the creation of a key with a user ID
          already existing in the local key database.  This flag can be
          used to override this check.

     ‘GPGME_CREATE_NOEXPIRE’
          SINCE: 1.9.0

          Request generation of keys that do not expire.

     ‘GPGME_CREATE_ADSK’
          SINCE: 1.24.0

          Add an ADSK to the key.  With this flag ALGO is expected to be
          the hexified fingerprint of the ADSK to be added; this must be
          a subkey.  If the string "default" is used for ALGO the engine
          will add all ADSK as it would do for new keys.

     After the operation completed successfully, information about the
     created key can be retrieved with ‘gpgme_op_genkey_result’.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_createkey_start (gpgme_ctx_t CTX,
          const char *USERID, const char *ALGO, unsigned long RESERVED,
          unsigned long EXPIRES, gpgme_key_t EXTRAKEY,
          unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_createkey_start’ initiates a
     ‘gpgme_op_createkey’ operation; see there for details.  It must be
     completed by calling ‘gpgme_wait’ on the context.  *Note Waiting
     For Completion::.

 -- Function: gpgme_error_t gpgme_op_createsubkey (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *ALGO, unsigned long RESERVED,
          unsigned long EXPIRES, unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_createsubkey’ creates and adds a new subkey
     to the primary OpenPGP key given by KEY.  The only allowed protocol
     in CTX is ‘GPGME_PROTOCOL_OPENPGP’.  Subkeys (aka secondary keys)
     are a concept in the OpenPGP protocol to bind several keys to a
     primary key.  As of now this function requires at least version
     2.1.13 of GnuPG.

     KEY specifies the key to operate on.

     ALGO specifies the algorithm for the new subkey.  For a list of
     supported algorithms, see the GnuPG manual.  If ALGO is ‘NULL’ or
     the string "default", the subkey is generated using the default
     algorithm for an encryption subkey of the engine.  If the string
     "future-default" is used the engine may use an encryption algorithm
     which is planned to be the default in a future release of the
     engine; however existing implementation of the protocol may not be
     able to already handle such future algorithms.

     RESERVED must be set to zero.

     EXPIRES specifies the expiration time in seconds.  If you supply 0,
     a reasonable expiration time is chosen.  Use the flag
     ‘GPGME_CREATE_NOEXPIRE’ to create keys that do not expire.  Note
     that this parameter takes an unsigned long value and not a ‘time_t’
     to avoid problems on systems which use a signed 32 bit ‘time_t’.
     Note further that the OpenPGP protocol uses 32 bit values for
     timestamps and thus can only encode dates up to the year 2106.

     FLAGS takes the same values as described above for
     ‘gpgme_op_createkey’.

     If the ‘GPGME_CREATE_ADSK’ flag is set, the subkey fingerprint
     given in the ‘algo’ parameter is added as an ADSK to the key.

     After the operation completed successfully, information about the
     created key can be retrieved with ‘gpgme_op_genkey_result’.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_createsubkey_start
          (gpgme_ctx_t CTX, gpgme_key_t KEY, const char *ALGO,
          unsigned long RESERVED, unsigned long EXPIRES,
          unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_createsubkey_start’ initiates a
     ‘gpgme_op_createsubkey’ operation; see there for details.  It must
     be completed by calling ‘gpgme_wait’ on the context.  *Note Waiting
     For Completion::.

 -- Function: gpgme_error_t gpgme_op_adduid (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_adduid’ adds a new user ID to the OpenPGP
     key given by KEY.  Adding additional user IDs after key creation is
     a feature of the OpenPGP protocol and thus the protocol for the
     context CTX must be set to OpenPGP. As of now this function
     requires at least version 2.1.13 of GnuPG.

     KEY specifies the key to operate on.

     USERID is the user ID to add to the key.  A user ID is commonly the
     mail address to be associated with the key.  GPGME does not require
     a specific syntax but if more than a mail address is given, RFC-822
     style format is suggested.  The value is expected to be in UTF-8
     encoding (i.e., no IDN encoding for mail addresses).  This is a
     required parameter.

     FLAGS are currently not used and must be set to zero.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_adduid_start (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_adduid_start’ initiates a ‘gpgme_op_adduid’
     operation; see there for details.  It must be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

 -- Function: gpgme_error_t gpgme_op_revuid (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_revuid’ revokes a user ID from the OpenPGP
     key given by KEY.  Revoking user IDs after key creation is a
     feature of the OpenPGP protocol and thus the protocol for the
     context CTX must be set to OpenPGP. As of now this function
     requires at least version 2.1.13 of GnuPG.

     KEY specifies the key to operate on.

     USERID is the user ID to be revoked from the key.  The user ID must
     be given verbatim because the engine does an exact and case
     sensitive match.  Thus the ‘uid’ field from the user ID object
     (‘gpgme_user_id_t’) is to be used.  This is a required parameter.

     FLAGS are currently not used and must be set to zero.

     Note that the engine won’t allow to revoke the last valid user ID.
     To change a user ID is better to first add the new user ID, then
     revoke the old one, and finally publish the key.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_revuid_start (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_revuid_start’ initiates a ‘gpgme_op_revuid’
     operation; see there for details.  It must be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

 -- Function: gpgme_error_t gpgme_op_set_ui_flag (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, cons char * NAME,
          cons char * VALUE);

     SINCE: 1.8.0

     The function ‘gpgme_op_set_uid_flag’ is used to set flags on a user
     ID from the OpenPGP key given by KEY.  Setting flags on user IDs
     after key creation is a feature of the OpenPGP protocol and thus
     the protocol for the context CTX must be set to OpenPGP.

     KEY specifies the key to operate on.  This parameters is required.

     USERID is the user ID of the key to be manipulated.  This user ID
     must be given verbatim because the engine does an exact and case
     sensitive match.  Thus the ‘uid’ field from the user ID object
     (‘gpgme_user_id_t’) is to be used.  This is a required parameter.

     NAME names the flag which is to be changed.  The only currently
     supported flag is:

     ‘primary’
          This sets the primary key flag on the given user ID. All other
          primary key flag on other user IDs are removed.  VALUE must be
          given as NULL. For technical reasons this functions bumps the
          creation timestamp of all affected self-signatures up by one
          second.  At least GnuPG version 2.1.20 is required.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_set_uid_flag_start
          (gpgme_ctx_t CTX, gpgme_key_t KEY, const char *USERID,
          cons char * NAME, cons char * VALUE);

     SINCE: 1.8.0

     The function ‘gpgme_op_set_uid_flag_start’ initiates a
     ‘gpgme_op_set_uid_flag’ operation; see there for details.  It must
     be completed by calling ‘gpgme_wait’ on the context.  *Note Waiting
     For Completion::.

 -- Function: gpgme_error_t gpgme_op_genkey (gpgme_ctx_t CTX,
          const char *PARMS, gpgme_data_t PUBLIC, gpgme_data_t SECRET)

     The function ‘gpgme_op_genkey’ generates a new key pair in the
     context CTX.  The meaning of PUBLIC and SECRET depends on the
     crypto backend.

     GPG does not support PUBLIC and SECRET, they should be ‘NULL’.
     GnuPG will generate a key pair and add it to the standard key ring.
     The fingerprint of the generated key is available with
     ‘gpgme_op_genkey_result’.

     GpgSM requires PUBLIC to be a writable data object.  GpgSM will
     generate a secret key (which will be stored by ‘gpg-agent’, and
     return a certificate request in PUBLIC, which then needs to be
     signed by the certification authority and imported before it can be
     used.  GpgSM does not make the fingerprint available.

     The argument PARMS specifies parameters for the key in an string
     that looks something like XML. The details about the format of
     PARMS are specific to the crypto engine used by CTX.  The first
     line of the parameters must be ‘<GnupgKeyParams format="internal">’
     and the last line must be ‘</GnupgKeyParams>’.  Every line in
     between the first and last lines is treated as a Header: Value
     pair.  In particular, no XML escaping is necessary if you need to
     include the characters ‘<’, ‘>’, or ‘&’.

     Here is an example for GnuPG as the crypto engine (all parameters
     of OpenPGP key generation are documented in the GPG manual):

          <GnupgKeyParms format="internal">
          Key-Type: default
          Subkey-Type: default
          Name-Real: Joe Tester
          Name-Comment: with stupid passphrase
          Name-Email: joe@foo.bar
          Expire-Date: 0
          Passphrase: abc
          </GnupgKeyParms>

     Here is an example for GpgSM as the crypto engine (all parameters
     of OpenPGP key generation are documented in the GPGSM manual):

          <GnupgKeyParms format="internal">
          Key-Type: RSA
          Key-Length: 1024
          Name-DN: C=de,O=g10 code,OU=Testlab,CN=Joe 2 Tester
          Name-Email: joe@foo.bar
          </GnupgKeyParms>

     Strings should be given in UTF-8 encoding.  The only format
     supported for now is “internal”.  The content of the
     ‘GnupgKeyParms’ container is passed verbatim to the crypto backend.
     Control statements are not allowed.

     After the operation completed successfully, the result can be
     retrieved with ‘gpgme_op_genkey_result’.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, ‘GPG_ERR_INV_VALUE’ if
     PARMS is not a well-formed string (e.g., does not have the expected
     tag-like headers and footers), ‘GPG_ERR_NOT_SUPPORTED’ if PUBLIC or
     SECRET is not valid, and ‘GPG_ERR_GENERAL’ if no key was created by
     the backend.

 -- Function: gpgme_error_t gpgme_op_genkey_start (gpgme_ctx_t CTX,
          const char *PARMS, gpgme_data_t PUBLIC, gpgme_data_t SECRET)

     The function ‘gpgme_op_genkey_start’ initiates a ‘gpgme_op_genkey’
     operation.  It can be completed by calling ‘gpgme_wait’ on the
     context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, ‘GPG_ERR_INV_VALUE’ if
     PARMS is not a valid XML string, and ‘GPG_ERR_NOT_SUPPORTED’ if
     PUBLIC or SECRET is not ‘NULL’.

 -- Data type: gpgme_genkey_result_t

     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_genkey’ operation.  After successfully generating a key,
     you can retrieve the pointer to the result with
     ‘gpgme_op_genkey_result’.  The structure contains the following
     members:

     ‘unsigned int primary : 1’
          This flag is set to 1 if a primary key was created and to 0 if
          not.

     ‘unsigned int sub : 1’
          This flag is set to 1 if a subkey was created and to 0 if not.

     ‘unsigned int uid : 1’
          This flag is set to 1 if a user ID was created and to 0 if
          not.

     ‘char *fpr’
          This is the fingerprint of the key that was created.  If both
          a primary and a subkey were generated, the fingerprint of the
          primary key will be returned.  If the crypto engine does not
          provide the fingerprint, ‘fpr’ will be a null pointer.

     ‘gpgme_data_t pubkey’
          SINCE: 1.7.0

          This will eventually be used to return the public key.  It is
          currently not used.

     ‘gpgme_data_t seckey’
          SINCE: 1.7.0

          This will eventually be used to return the secret key.  It is
          currently not used.

 -- Function: gpgme_genkey_result_t gpgme_op_genkey_result
          (gpgme_ctx_t CTX)

     The function ‘gpgme_op_genkey_result’ returns a
     ‘gpgme_genkey_result_t’ pointer to a structure holding the result
     of a ‘gpgme_op_genkey’ operation.  The pointer is only valid if the
     last operation on the context was a ‘gpgme_op_genkey’ or
     ‘gpgme_op_genkey_start’ operation, and if this operation finished
     successfully.  The returned pointer is only valid until the next
     operation is started on the context.


File: gpgme.info,  Node: Signing Keys,  Next: Exporting Keys,  Prev: Generating Keys,  Up: Key Management

7.5.6 Signing Keys
------------------

Key signatures are a unique concept of the OpenPGP protocol.  They can
be used to certify the validity of a key and are used to create the
Web-of-Trust (WoT). Instead of using the ‘gpgme_op_interact’ function
along with a finite state machine, GPGME provides a convenient function
to create key signatures when using modern GnuPG versions.

 -- Function: gpgme_error_t gpgme_op_keysign (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, unsigned long EXPIRES,
          unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_keysign’ adds a new key signature to the
     public key KEY.  This function requires at least version 2.1.12 of
     GnuPG.

     CTX is the usual context which describes the protocol to use (which
     must be OpenPGP) and has also the list of signer keys to be used
     for the signature.  The common case is to use the default key for
     signing other keys.  If another key or more than one key shall be
     used for a key signature, ‘gpgme_signers_add’ can be used.  *Note
     Selecting Signers::.

     KEY specifies the key to operate on.

     USERID selects the user ID or user IDs to be signed.  If USERID is
     set to ‘NULL’ all valid user IDs are signed.  The user ID must be
     given verbatim because the engine does an exact and case sensitive
     match.  Thus the ‘uid’ field from the user ID object
     (‘gpgme_user_id_t’) is to be used.  To select more than one user ID
     put them all into one string separated by linefeeds characters
     (‘\n’) and set the flag ‘GPGME_KEYSIGN_LFSEP’.

     EXPIRES specifies the expiration time of the new signature in
     seconds.  The common case is to use 0 to not set an expiration
     date.  However, if the configuration of the engine defines a
     default expiration for key signatures, that is still used unless
     the flag ‘GPGME_KEYSIGN_NOEXPIRE’ is used.  Note that this
     parameter takes an unsigned long value and not a ‘time_t’ to avoid
     problems on systems which use a signed 32 bit ‘time_t’.  Note
     further that the OpenPGP protocol uses 32 bit values for timestamps
     and thus can only encode dates up to the year 2106.

     FLAGS can be set to the bit-wise OR of the following flags:

     ‘GPGME_KEYSIGN_LOCAL’
          SINCE: 1.7.0

          Instead of creating an exportable key signature, create a key
          signature which is is marked as non-exportable.

     ‘GPGME_KEYSIGN_LFSEP’
          SINCE: 1.7.0

          Although linefeeds are uncommon in user IDs this flag is
          required to explicitly declare that USERID may contain several
          linefeed separated user IDs.

     ‘GPGME_KEYSIGN_NOEXPIRE’
          Force the creation of a key signature without an expiration
          date.  This overrides EXPIRE and any local configuration of
          the engine.

     ‘GPGME_KEYSIGN_FORCE’
          Force the creation of a new signature even if one already
          exists.  This flag has an effect only if the gpg version is at
          least 2.2.28 but won’t return an error with older versions.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_keysign_start (gpgme_ctx_t CTX,
          gpgme_key_t KEY, const char *USERID, unsigned long EXPIRES,
          unsigned int FLAGS);

     SINCE: 1.7.0

     The function ‘gpgme_op_keysign_start’ initiates a
     ‘gpgme_op_keysign’ operation; see there for details.  It must be
     completed by calling ‘gpgme_wait’ on the context.  *Note Waiting
     For Completion::.

 -- Function: gpgme_error_t gpgme_op_revsig (gpgme_ctx_t CTX,
          gpgme_key_t KEY, gpgme_key_t SIGNING_KEY, const char *USERID,
          unsigned int FLAGS);

     SINCE: 1.14.1

     The function ‘gpgme_op_revsig’ revokes key signatures of the public
     key KEY made with the key SIGNING_KEY.  This function requires at
     least version 2.2.24 of GnuPG.

     KEY specifies the key to operate on.

     SIGNING_KEY specifies the key whose signatures shall be revoked.

     USERID selects the user ID or user IDs whose signatures shall be
     revoked.  If USERID is set to ‘NULL’ the signatures on all user IDs
     are revoked.  The user ID must be given verbatim because the engine
     does an exact and case sensitive match.  Thus the ‘uid’ field from
     the user ID object (‘gpgme_user_id_t’) is to be used.  To select
     more than one user ID put them all into one string separated by
     linefeeds characters (‘\n’) and set the flag ‘GPGME_REVSIG_LFSEP’.

     FLAGS can be set to the bit-wise OR of the following flags:

     ‘GPGME_REVSIG_LFSEP’
          SINCE: 1.14.1

          Although linefeeds are uncommon in user IDs this flag is
          required to explicitly declare that USERID may contain several
          linefeed separated user IDs.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_revsig_start (gpgme_ctx_t CTX,
          gpgme_key_t KEY, gpgme_key_t SIGNING_KEY, const char *USERID,
          unsigned int FLAGS);

     SINCE: 1.14.1

     The function ‘gpgme_op_revsig_start’ initiates a ‘gpgme_op_revsig’
     operation; see there for details.  It must be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.


File: gpgme.info,  Node: Exporting Keys,  Next: Importing Keys,  Prev: Signing Keys,  Up: Key Management

7.5.7 Exporting Keys
--------------------

Exporting keys means the same as running ‘gpg’ with the command
‘--export’.  However, a mode flag can be used to change the way the
export works.  The available mode flags are described below, they may be
or-ed together.

‘GPGME_EXPORT_MODE_EXTERN’
     If this bit is set, the output is send directly to the default
     keyserver.  This is currently only allowed for OpenPGP keys.  It is
     good practise to not send more than a few dozens key to a keyserver
     at one time.  Using this flag requires that the KEYDATA argument of
     the export function is set to ‘NULL’.

‘GPGME_EXPORT_MODE_MINIMAL’
     SINCE: 1.3.1

     If this bit is set, the smallest possible key is exported.  For
     OpenPGP keys it removes all signatures except for the latest
     self-signatures.  For X.509 keys it has no effect.

‘GPGME_EXPORT_MODE_SSH’
     SINCE: 1.4.0

     If this bit is set, the latest authentication key of the requested
     OpenPGP key is exported in the OpenSSH public key format.  This
     accepts just a single key; to force the export of a specific subkey
     a fingerprint pattern with an appended exclamation mark may be
     used.

‘GPGME_EXPORT_MODE_SECRET’
     SINCE: 1.6.0

     Instead of exporting the public key, the secret key is exported.
     This may not be combined with ‘GPGME_EXPORT_MODE_EXTERN’.  For
     X.509 the export format is PKCS#8.

‘GPGME_EXPORT_MODE_SECRET_SUBKEY’
     SINCE: 1.17.0

     If this bit is set, then a secret subkey is exported.  The subkey
     to export must be specified with fingerprint pattern with an
     appended exclamation mark.  This is currently only allowed for
     OpenPGP keys.  This flag may not be combined with
     ‘GPGME_EXPORT_MODE_EXTERN’.  This flag is not supported by the
     export functions that take an array of keys.

‘GPGME_EXPORT_MODE_RAW’
     SINCE: 1.6.0

     If this flag is used with ‘GPGME_EXPORT_MODE_SECRET’ for an X.509
     key the export format will be changed to PKCS#1.  This flag may not
     be used with OpenPGP.

‘GPGME_EXPORT_MODE_PKCS12’
     SINCE: 1.6.0

     If this flag is used with ‘GPGME_EXPORT_MODE_SECRET’ for an X.509
     key the export format will be changed to PKCS#12 which also
     includes the certificate.  This flag may not be used with OpenPGP.

 -- Function: gpgme_error_t gpgme_op_export (gpgme_ctx_t CTX,
          const char *PATTERN, gpgme_export_mode_t MODE,
          gpgme_data_t KEYDATA)
     The function ‘gpgme_op_export’ extracts public keys and returns
     them in the data buffer KEYDATA.  The output format of the key data
     returned is determined by the ASCII armor attribute set for the
     context CTX, or, if that is not set, by the encoding specified for
     KEYDATA.

     If PATTERN is ‘NULL’, all available keys are returned.  Otherwise,
     PATTERN contains an engine specific expression that is used to
     limit the list to all keys matching the pattern.

     MODE is usually 0; other values are described above.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation completed successfully, ‘GPG_ERR_INV_VALUE’ if KEYDATA is
     not a valid empty data buffer, and passes through any errors that
     are reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_export_start (gpgme_ctx_t CTX,
          const char *PATTERN, gpgme_export_mode_t MODE,
          gpgme_data_t KEYDATA)
     The function ‘gpgme_op_export_start’ initiates a ‘gpgme_op_export’
     operation.  It can be completed by calling ‘gpgme_wait’ on the
     context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     KEYDATA is not a valid empty data buffer.

 -- Function: gpgme_error_t gpgme_op_export_ext (gpgme_ctx_t CTX,
          const char *PATTERN[], gpgme_export_mode_t MODE,
          gpgme_data_t KEYDATA)
     The function ‘gpgme_op_export’ extracts public keys and returns
     them in the data buffer KEYDATA.  The output format of the key data
     returned is determined by the ASCII armor attribute set for the
     context CTX, or, if that is not set, by the encoding specified for
     KEYDATA.

     If PATTERN or *PATTERN is ‘NULL’, all available keys are returned.
     Otherwise, PATTERN is a ‘NULL’ terminated array of strings that are
     used to limit the list to all keys matching at least one of the
     patterns verbatim.

     MODE is usually 0; other values are described above.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation completed successfully, ‘GPG_ERR_INV_VALUE’ if KEYDATA is
     not a valid empty data buffer, and passes through any errors that
     are reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_export_ext_start (gpgme_ctx_t CTX,
          const char *PATTERN[], gpgme_export_mode_t MODE,
          gpgme_data_t KEYDATA)
     The function ‘gpgme_op_export_ext_start’ initiates a
     ‘gpgme_op_export_ext’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     KEYDATA is not a valid empty data buffer.

 -- Function: gpgme_error_t gpgme_op_export_keys (gpgme_ctx_t CTX,
          gpgme_key_t keys[], gpgme_export_mode_t MODE,
          gpgme_data_t KEYDATA)
     SINCE: 1.2.0

     The function ‘gpgme_op_export_keys’ extracts public keys and
     returns them in the data buffer KEYDATA.  The output format of the
     key data returned is determined by the ASCII armor attribute set
     for the context CTX, or, if that is not set, by the encoding
     specified for KEYDATA.

     The keys to export are taken form the ‘NULL’ terminated array KEYS.
     Only keys of the currently selected protocol of CTX which do have a
     fingerprint set are considered for export.  Other keys specified by
     the KEYS are ignored.  In particular OpenPGP keys retrieved via an
     external key listing are not included.

     MODE is usually 0; other values are described above.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation completed successfully, ‘GPG_ERR_INV_VALUE’ if KEYDATA is
     not a valid empty data buffer, ‘GPG_ERR_NO_DATA’ if no useful keys
     are in KEYS and passes through any errors that are reported by the
     crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_export_keys_start (gpgme_ctx_t CTX,
          gpgme_key_t KEYS[], gpgme_export_mode_t MODE,
          gpgme_data_t KEYDATA)
     SINCE: 1.2.0

     The function ‘gpgme_op_export_keys_start’ initiates a
     ‘gpgme_op_export_ext’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     KEYDATA is not a valid empty data buffer, ‘GPG_ERR_NO_DATA’ if no
     useful keys are in KEYS and passes through any errors that are
     reported by the crypto engine support routines.


File: gpgme.info,  Node: Importing Keys,  Next: Deleting Keys,  Prev: Exporting Keys,  Up: Key Management

7.5.8 Importing Keys
--------------------

Importing keys means the same as running ‘gpg’ with the command
‘--import’.

 -- Function: gpgme_error_t gpgme_op_import (gpgme_ctx_t CTX,
          gpgme_data_t KEYDATA)
     The function ‘gpgme_op_import’ adds the keys in the data buffer
     KEYDATA to the key ring of the crypto engine used by CTX.  The
     format of KEYDATA can be ASCII armored, for example, but the
     details are specific to the crypto engine.

     After the operation completed successfully, the result can be
     retrieved with ‘gpgme_op_import_result’.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     import was completed successfully, ‘GPG_ERR_INV_VALUE’ if CTX or
     KEYDATA is not a valid pointer, and ‘GPG_ERR_NO_DATA’ if KEYDATA is
     an empty data buffer.

 -- Function: gpgme_error_t gpgme_op_import_start (gpgme_ctx_t CTX,
          gpgme_data_t KEYDATA)
     The function ‘gpgme_op_import_start’ initiates a ‘gpgme_op_import’
     operation.  It can be completed by calling ‘gpgme_wait’ on the
     context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     import could be started successfully, ‘GPG_ERR_INV_VALUE’ if CTX or
     KEYDATA is not a valid pointer, and ‘GPG_ERR_NO_DATA’ if KEYDATA is
     an empty data buffer.

 -- Function: gpgme_error_t gpgme_op_import_keys (gpgme_ctx_t CTX,
          gpgme_key_t *KEYS)
     SINCE: 1.2.0

     The function ‘gpgme_op_import_keys’ adds the keys described by the
     ‘NULL’ terminated array KEYS to the key ring of the crypto engine
     used by CTX.  It is used to actually import and make keys permanent
     which have been retrieved from an external source (i.e., using
     ‘GPGME_KEYLIST_MODE_EXTERN’) earlier.  The external keylisting must
     have been made with the same context configuration (in particular
     the same home directory).  (1)  Note that for OpenPGP this may
     require another access to the keyserver over the network.

     Only keys of the currently selected protocol of CTX are considered
     for import.  Other keys specified by the KEYS are ignored.  As of
     now all considered keys must have been retrieved using the same
     method, i.e., the used key listing mode must be identical.

     After the operation completed successfully, the result can be
     retrieved with ‘gpgme_op_import_result’.

     To move keys from one home directory to another, export and import
     the keydata using ‘gpgme_op_export’ and ‘gpgme_op_import’.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     import was completed successfully, ‘GPG_ERR_INV_VALUE’ if CTX is
     not a valid pointer, ‘GPG_ERR_CONFLICT’ if the key listing mode
     does not match, and ‘GPG_ERR_NO_DATA’ if no keys were considered
     for import.

 -- Function: gpgme_error_t gpgme_op_import_keys_start (gpgme_ctx_t CTX,
          gpgme_key_t *KEYS)
     SINCE: 1.2.0

     The function ‘gpgme_op_import_keys_start’ initiates a
     ‘gpgme_op_import_keys’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     import was started successfully, ‘GPG_ERR_INV_VALUE’ if CTX is not
     a valid pointer, ‘GPG_ERR_CONFLICT’ if the key listing mode does
     not match, and ‘GPG_ERR_NO_DATA’ if no keys were considered for
     import.

 -- Function: gpgme_error_t gpgme_op_receive_keys (gpgme_ctx_t CTX,
          const char *KEYIDS[])
     SINCE: 1.17.0

     The function ‘gpgme_op_receive_keys’ adds the keys described by the
     ‘NULL’ terminated array KEYIDS to the key ring of the crypto engine
     used by CTX.  It is used to retrieve and import keys from an
     external source.  This function currently works only for OpenPGP.

     After the operation completed successfully, the result can be
     retrieved with ‘gpgme_op_import_result’.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     import was completed successfully, ‘GPG_ERR_INV_VALUE’ if CTX is
     not a valid pointer, and ‘GPG_ERR_NO_DATA’ if no keys were
     considered for import.

 -- Function: gpgme_error_t gpgme_op_receive_keys_start
          (gpgme_ctx_t CTX, const char *KEYIDS[])
     SINCE: 1.17.0

     The function ‘gpgme_op_receive_keys_start’ initiates a
     ‘gpgme_op_receive_keys’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     import was started successfully, ‘GPG_ERR_INV_VALUE’ if CTX is not
     a valid pointer, and ‘GPG_ERR_NO_DATA’ if no keys were considered
     for import.

 -- Data type: gpgme_import_status_t
     This is a pointer to a structure used to store a part of the result
     of a ‘gpgme_op_import’ operation.  For each considered key one
     status is added that contains information about the result of the
     import.  The structure contains the following members:

     ‘gpgme_import_status_t next’
          This is a pointer to the next status structure in the linked
          list, or ‘NULL’ if this is the last element.

     ‘char *fpr’
          This is the fingerprint of the key that was considered, or
          ‘NULL’ if the fingerprint of the key is not known, e.g.,
          because the key to import was encrypted and decryption failed.

     ‘gpgme_error_t result’
          If the import was not successful, this is the error value that
          caused the import to fail.  Otherwise the error code is
          ‘GPG_ERR_NO_ERROR’.

     ‘unsigned int status’
          This is a bit-wise OR of the following flags that give more
          information about what part of the key was imported.  If the
          key was already known, this might be 0.

          ‘GPGME_IMPORT_NEW’
               The key was new.

          ‘GPGME_IMPORT_UID’
               The key contained new user IDs.

          ‘GPGME_IMPORT_SIG’
               The key contained new signatures.

          ‘GPGME_IMPORT_SUBKEY’
               The key contained new sub keys.

          ‘GPGME_IMPORT_SECRET’
               The key contained a secret key.

 -- Data type: gpgme_import_result_t
     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_import’ operation.  After a successful import operation,
     you can retrieve the pointer to the result with
     ‘gpgme_op_import_result’.  The structure contains the following
     members:

     ‘int considered’
          The total number of considered keys.

     ‘int no_user_id’
          The number of keys without user ID.

     ‘int imported’
          The total number of imported keys.

     ‘int imported_rsa’
          The number of imported RSA keys.

     ‘int unchanged’
          The number of unchanged keys.

     ‘int new_user_ids’
          The number of new user IDs.

     ‘int new_sub_keys’
          The number of new sub keys.

     ‘int new_signatures’
          The number of new signatures.

     ‘int new_revocations’
          The number of new revocations.

     ‘int secret_read’
          The total number of secret keys read.

     ‘int secret_imported’
          The number of imported secret keys.

     ‘int secret_unchanged’
          The number of unchanged secret keys.

     ‘int not_imported’
          The number of keys not imported.

     ‘gpgme_import_status_t imports’
          A list of gpgme_import_status_t objects which contain more
          information about the keys for which an import was attempted.

     ‘int skipped_v3_keys’
          For security reasons modern versions of GnuPG do not anymore
          support v3 keys (created with PGP 2.x) and ignores them on
          import.  This counter provides the number of such skipped v3
          keys.

 -- Function: gpgme_import_result_t gpgme_op_import_result
          (gpgme_ctx_t CTX)
     The function ‘gpgme_op_import_result’ returns a
     ‘gpgme_import_result_t’ pointer to a structure holding the result
     of a ‘gpgme_op_import’ operation.  The pointer is only valid if the
     last operation on the context was a ‘gpgme_op_import’ or
     ‘gpgme_op_import_start’ operation, and if this operation finished
     successfully.  The returned pointer is only valid until the next
     operation is started on the context.

   ---------- Footnotes ----------

   (1) Thus it is a replacement for the usual workaround of exporting
and then importing a key to make an X.509 key permanent.


File: gpgme.info,  Node: Deleting Keys,  Next: Changing Passphrases,  Prev: Importing Keys,  Up: Key Management

7.5.9 Deleting Keys
-------------------

 -- Function: gpgme_error_t gpgme_op_delete_ext (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, unsigned int FLAGS)
     SINCE: 1.9.1

     The function ‘gpgme_op_delete_ext’ deletes the key KEY from the key
     ring of the crypto engine used by CTX.

     FLAGS can be set to the bit-wise OR of the following flags:

     ‘GPGME_DELETE_ALLOW_SECRET’
          SINCE: 1.9.1

          If not set, only public keys are deleted.  If set, secret keys
          are deleted as well, if that is supported.

     ‘GPGME_DELETE_FORCE’
          SINCE: 1.9.1

          If set, the user is not asked to confirm the deletion.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the key
     was deleted successfully, ‘GPG_ERR_INV_VALUE’ if CTX or KEY is not
     a valid pointer, ‘GPG_ERR_NO_PUBKEY’ if KEY could not be found in
     the keyring, ‘GPG_ERR_AMBIGUOUS_NAME’ if the key was not specified
     unambiguously, and ‘GPG_ERR_CONFLICT’ if the secret key for KEY is
     available, but ALLOW_SECRET is zero.

 -- Function: gpgme_error_t gpgme_op_delete_ext_start (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, unsigned int FLAGS)
     SINCE: 1.9.1

     The function ‘gpgme_op_delete_ext_start’ initiates a
     ‘gpgme_op_delete’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation was started successfully, and ‘GPG_ERR_INV_VALUE’ if CTX
     or KEY is not a valid pointer.

   The following functions allow only to use one particular flag.  Their
use is thus deprecated.

 -- Function: gpgme_error_t gpgme_op_delete (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, int ALLOW_SECRET)
     Similar to ‘gpgme_op_delete_ext’, but only the flag
     ‘GPGME_DELETE_ALLOW_SECRET’ can be provided.  Actually all true
     values are mapped to this flag.

 -- Function: gpgme_error_t gpgme_op_delete_start (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, int ALLOW_SECRET)
     Similar to ‘gpgme_op_delete_ext_start’, but only the flag
     ‘GPGME_DELETE_ALLOW_SECRET’ can be provided.  Actually all true
     values are mapped to this flag.


File: gpgme.info,  Node: Changing Passphrases,  Next: Changing TOFU Data,  Prev: Deleting Keys,  Up: Key Management

7.5.10 Changing Passphrases
---------------------------

 -- Function: gpgme_error_t gpgme_op_passwd (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, unsigned int FLAGS)

     SINCE: 1.3.0

     The function ‘gpgme_op_passwd’ changes the passphrase of the
     private key associated with KEY.  The only allowed value for FLAGS
     is ‘0’.  The backend engine will usually popup a window to ask for
     the old and the new passphrase.  Thus this function is not useful
     in a server application (where passphrases are not required
     anyway).

     Note that old ‘gpg’ engines (before version 2.0.15) do not support
     this command and will silently ignore it.

 -- Function: gpgme_error_t gpgme_op_passwd_start (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, unsigned int FLAGS)

     SINCE: 1.3.0

     The function ‘gpgme_op_passwd_start’ initiates a ‘gpgme_op_passwd’
     operation.  It can be completed by calling ‘gpgme_wait’ on the
     context.  *Note Waiting For Completion::.

     The function returns ‘0’ if the operation was started successfully,
     and an error code if one of the arguments is not valid or the
     oepration could not be started.


File: gpgme.info,  Node: Changing TOFU Data,  Next: Advanced Key Editing,  Prev: Changing Passphrases,  Up: Key Management

7.5.11 Changing TOFU Data
-------------------------

The OpenPGP engine features a Trust-On-First-Use (TOFU) key validation
model.  For resolving conflicts it is necessary to declare the policy
for a key.  See the GnuPG manual for details on the TOFU implementation.

 -- Data type: enum gpgme_tofu_policy_t
     SINCE: 1.7.0

     The ‘gpgme_tofu_policy_t’ type specifies the set of possible policy
     values that are supported by GPGME:

     ‘GPGME_TOFU_POLICY_AUTO’
          Set the policy to “auto”.
     ‘GPGME_TOFU_POLICY_GOOD’
          Set the policy to “good”.
     ‘GPGME_TOFU_POLICY_BAD’
          Set the policy to “bad”.
     ‘GPGME_TOFU_POLICY_ASK’
          Set the policy to “ask”.
     ‘GPGME_TOFU_POLICY_UNKNOWN’
          Set the policy to “unknown”.

   To change the policy for a key the following functions can be used:

 -- Function: gpgme_error_t gpgme_op_tofu_policy (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, gpgme_tofu_policy_t POLICY)

     SINCE: 1.7.0

     The function ‘gpgme_op_tofu_policy’ changes the TOFU policy of KEY.
     The valid values for POLICY are listed above.  As of now this
     function does only work for OpenPGP and requires at least version
     2.1.10 of GnuPG.

     The function returns zero on success, ‘GPG_ERR_NOT_SUPPORTED’ if
     the engine does not support the command, or a bunch of other error
     codes.

 -- Function: gpgme_error_t gpgme_op_tofu_policy_start (gpgme_ctx_t CTX,
          const gpgme_key_t KEY, gpgme_tofu_policy_t POLICY)

     SINCE: 1.7.0

     The function ‘gpgme_op_tofu_policy_start’ initiates a
     ‘gpgme_op_tofu_policy’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns ‘0’ if the operation was started successfully,
     and an error code if one of the arguments is not valid or the
     oepration could not be started.


File: gpgme.info,  Node: Advanced Key Editing,  Prev: Changing TOFU Data,  Up: Key Management

7.5.12 Advanced Key Editing
---------------------------

 -- Data type: gpgme_error_t (*gpgme_interact_cb_t) (void *HANDLE,
          const char *STATUS, const char *ARGS, int FD)

     SINCE: 1.7.0

     The ‘gpgme_interact_cb_t’ type is the type of functions which GPGME
     calls if it a key interact operation is on-going.  The status
     keyword STATUS and the argument line ARGS are passed through by
     GPGME from the crypto engine.  An empty string represents EOF. The
     file descriptor FD is -1 for normal status messages.  If STATUS
     indicates a command rather than a status message, the response to
     the command should be written to FD.  The HANDLE is provided by the
     user at start of operation.

     The function should return ‘GPG_ERR_FALSE’ if it did not handle the
     status code, ‘0’ for success, or any other error value.

 -- Function: gpgme_error_t gpgme_op_interact (gpgme_ctx_t CTX,
          gpgme_key_t KEY, unsigned int FLAGS, gpgme_interact_cb_t FNC,
          void *HANDLE, gpgme_data_t OUT)

     SINCE: 1.7.0

     The function ‘gpgme_op_interact’ processes the key KEY
     interactively, using the interact callback function FNC with the
     handle HANDLE.  The callback is invoked for every status and
     command request from the crypto engine.  The output of the crypto
     engine is written to the data object OUT.

     Note that the protocol between the callback function and the crypto
     engine is specific to the crypto engine and no further support in
     implementing this protocol correctly is provided by GPGME.

     FLAGS modifies the behaviour of the function; the only defined bit
     value is:

     ‘GPGME_INTERACT_CARD’
          SINCE: 1.7.0

          This is used for smartcard based keys and uses gpg’s
          ‘--card-edit’ command.

     The function returns ‘0’ if the edit operation completes
     successfully, ‘GPG_ERR_INV_VALUE’ if CTX or KEY is not a valid
     pointer, and any error returned by the crypto engine or the edit
     callback handler.

 -- Function: gpgme_error_t gpgme_op_interact_start (gpgme_ctx_t CTX,
          gpgme_key_t KEY, unsigned int FLAGS, gpgme_interact_cb_t FNC,
          void *HANDLE, gpgme_data_t OUT)

     SINCE: 1.7.0

     The function ‘gpgme_op_interact_start’ initiates a
     ‘gpgme_op_interact’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns ‘0’ if the operation was started successfully,
     and ‘GPG_ERR_INV_VALUE’ if CTX or KEY is not a valid pointer.


File: gpgme.info,  Node: Crypto Operations,  Next: Miscellaneous,  Prev: Key Management,  Up: Contexts

7.6 Crypto Operations
=====================

Sometimes, the result of a crypto operation returns a list of invalid
keys encountered in processing the request.  The following structure is
used to hold information about such a key.

 -- Data type: gpgme_invalid_key_t
     This is a pointer to a structure used to store a part of the result
     of a crypto operation which takes user IDs as one input parameter.
     The structure contains the following members:

     ‘gpgme_invalid_key_t next’
          This is a pointer to the next invalid key structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘char *fpr’
          The fingerprint or key ID of the invalid key encountered.

     ‘gpgme_error_t reason’
          An error code describing the reason why the key was found
          invalid.

* Menu:

* Decrypt::                       Decrypting a ciphertext.
* Verify::                        Verifying a signature.
* Decrypt and Verify::            Decrypting a signed ciphertext.
* Sign::                          Creating a signature.
* Encrypt::                       Encrypting a plaintext.


File: gpgme.info,  Node: Decrypt,  Next: Verify,  Up: Crypto Operations

7.6.1 Decrypt
-------------

 -- Function: gpgme_error_t gpgme_op_decrypt (gpgme_ctx_t CTX,
          gpgme_data_t CIPHER, gpgme_data_t PLAIN)
     The function ‘gpgme_op_decrypt’ decrypts the ciphertext in the data
     object CIPHER or, if a file name is set on the data object, the
     ciphertext stored in the corresponding file.  The decrypted
     ciphertext is stored into the data object PLAIN or written to the
     file set with ‘gpgme_data_set_file_name’ for the data object PLAIN.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     ciphertext could be decrypted successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, CIPHER or PLAIN is not a valid pointer, ‘GPG_ERR_NO_DATA’ if
     CIPHER does not contain any data to decrypt,
     ‘GPG_ERR_DECRYPT_FAILED’ if CIPHER is not a valid cipher text,
     ‘GPG_ERR_BAD_PASSPHRASE’ if the passphrase for the secret key could
     not be retrieved, and passes through some errors that are reported
     by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_decrypt_start (gpgme_ctx_t CTX,
          gpgme_data_t CIPHER, gpgme_data_t PLAIN)
     The function ‘gpgme_op_decrypt_start’ initiates a
     ‘gpgme_op_decrypt’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     CIPHER or PLAIN is not a valid pointer.

 -- Function: gpgme_error_t gpgme_op_decrypt_ext ( gpgme_ctx_t CTX,
          gpgme_decrypt_flags_t FLAGS, gpgme_data_t CIPHER,
          gpgme_data_t PLAIN)

     SINCE: 1.8.0

     The function ‘gpgme_op_decrypt_ext’ is the same as
     ‘gpgme_op_decrypt’ but has an additional argument FLAGS.  If FLAGS
     is 0 both function behave identically.

     If the flag ‘GPGME_DECRYPT_ARCHIVE’ is set, then an encrypted
     archive in the data object CIPHER is decrypted and extracted.  The
     content of the archive is extracted into a directory named
     ‘GPGARCH_n_’ (where ‘n’ is a number) or into the directory set with
     ‘gpgme_data_set_file_name’ for the data object PLAIN.

     The value in FLAGS is a bitwise-or combination of one or multiple
     of the following bit values:

     ‘GPGME_DECRYPT_VERIFY’
          SINCE: 1.8.0

          The ‘GPGME_DECRYPT_VERIFY’ symbol specifies that this function
          shall exactly act as ‘gpgme_op_decrypt_verify’.

     ‘GPGME_DECRYPT_ARCHIVE’
          SINCE: 1.19.0

          The ‘GPGME_DECRYPT_ARCHIVE’ symbol specifies that the input is
          an encrypted archive that shall be decrypted and extracted.
          This feature is currently only supported for the OpenPGP
          crypto engine and requires GnuPG 2.4.1.

     ‘GPGME_DECRYPT_UNWRAP’
          SINCE: 1.8.0

          The ‘GPGME_DECRYPT_UNWRAP’ symbol specifies that the output
          shall be an OpenPGP message with only the encryption layer
          removed.  This requires GnuPG 2.1.12 and works only for
          OpenPGP. This is the counterpart to ‘GPGME_ENCRYPT_WRAP’.

     The function returns the error codes as described for
     ‘gpgme_op_decrypt’.

 -- Function: gpgme_error_t gpgme_op_decrypt_ext_start (
          gpgme_ctx_t CTX, gpgme_decrypt_flags_t FLAGS,
          gpgme_data_t CIPHER, gpgme_data_t PLAIN)

     SINCE: 1.8.0

     The function ‘gpgme_op_decrypt_ext_start’ initiates a
     ‘gpgme_op_decrypt_ext’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     CIPHER or PLAIN is not a valid pointer.

 -- Data type: gpgme_recipient_t
     SINCE: 1.1.0

     This is a pointer to a structure used to store information about
     the recipient of an encrypted text which is decrypted in a
     ‘gpgme_op_decrypt’ operation.  This information (except for the
     status field) is even available before the operation finished
     successfully, for example in a passphrase callback.  The structure
     contains the following members:

     ‘gpgme_recipient_t next’
          This is a pointer to the next recipient structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘gpgme_pubkey_algo_t’
          The public key algorithm used in the encryption.

     ‘char *keyid’
          This is the key ID of the key (in hexadecimal digits) used as
          recipient.

     ‘gpgme_error_t status’
          This is an error number with the error code GPG_ERR_NO_SECKEY
          if the secret key for this recipient is not available, and 0
          otherwise.

 -- Data type: gpgme_decrypt_result_t
     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_decrypt’ operation.  After successfully decrypting data,
     you can retrieve the pointer to the result with
     ‘gpgme_op_decrypt_result’.  As with all result structures, it this
     structure shall be considered read-only and an application must not
     allocate such a strucure on its own.  The structure contains the
     following members:

     ‘char *unsupported_algorithm’
          If an unsupported algorithm was encountered, this string
          describes the algorithm that is not supported.

     ‘unsigned int wrong_key_usage : 1’
          SINCE: 0.9.0 This is true if the key was not used according to
          its policy.

     ‘unsigned int legacy_cipher_nomdc : 1’
          SINCE: 1.11.2 The message was made by a legacy algorithm
          without any integrity protection.  This might be an old but
          legitimate message.

     ‘unsigned int is_mime : 1;’
          SINCE: 1.11.0 The message claims that the content is a MIME
          object.

     ‘unsigned int is_de_vs : 1;’
          SINCE: 1.10.0 The message was encrypted in a VS-NfD compliant
          way.  This is a specification in Germany for a restricted
          communication level.

     ‘unsigned int beta_compliance : 1;’
          SINCE: 1.24.0 The compliance flags (e.g.  is_de_vs) are set
          but the software has not yet been approved or is in a beta
          state.

     ‘gpgme_recipient_t recipients’
          SINCE: 1.1.0

          This is a linked list of recipients to which this message was
          encrypted.

     ‘char *file_name’
          This is the filename of the original plaintext message file if
          it is known, otherwise this is a null pointer.

     ‘char *session_key’
          SINCE: 1.8.0

          A textual representation (nul-terminated string) of the
          session key used in symmetric encryption of the message, if
          the context has been set to export session keys (see
          ‘gpgme_set_ctx_flag, "export-session-key"’), and a session key
          was available for the most recent decryption operation.
          Otherwise, this is a null pointer.

          You must not try to access this member of the struct unless
          ‘gpgme_set_ctx_flag (ctx, "export-session-key")’ returns
          success or ‘gpgme_get_ctx_flag (ctx, "export-session-key")’
          returns true (non-empty string).

     ‘char *symkey_algo’
          SINCE: 1.11.0

          A string with the symmetric encryption algorithm and mode
          using the format "<algo>.<mode>".  Note that the deprecated
          non-MDC encryption mode of OpenPGP is given as "PGPCFB".

 -- Function: gpgme_decrypt_result_t gpgme_op_decrypt_result
          (gpgme_ctx_t CTX)
     The function ‘gpgme_op_decrypt_result’ returns a
     ‘gpgme_decrypt_result_t’ pointer to a structure holding the result
     of a ‘gpgme_op_decrypt’ operation.  The pointer is only valid if
     the last operation on the context was a ‘gpgme_op_decrypt’ or
     ‘gpgme_op_decrypt_start’ operation.  If the operation failed this
     might be a ‘NULL’ pointer.  The returned pointer is only valid
     until the next operation is started on the context.


File: gpgme.info,  Node: Verify,  Next: Decrypt and Verify,  Prev: Decrypt,  Up: Crypto Operations

7.6.2 Verify
------------

 -- Function: gpgme_error_t gpgme_op_verify (gpgme_ctx_t CTX,
          gpgme_data_t SIG, gpgme_data_t SIGNED_TEXT,
          gpgme_data_t PLAIN)
     The function ‘gpgme_op_verify’ verifies that the signature in the
     data object SIG is a valid signature.  If SIG is a detached
     signature, then the signed text should be provided in SIGNED_TEXT
     and PLAIN should be a null pointer.  Otherwise, if SIG is a normal
     (or cleartext) signature, SIGNED_TEXT should be a null pointer and
     PLAIN should be a writable data object that will contain the
     plaintext after successful verification.  If a file name is set on
     the data object SIG (or on the data object SIGNED_TEXT), then the
     data of the signature (resp.  the data of the signed text) is not
     read from the data object but from the file with the given file
     name.  If a file name is set on the data object PLAIN then the
     plaintext is not stored in the data object but it is written to a
     file with the given file name.

     The results of the individual signature verifications can be
     retrieved with ‘gpgme_op_verify_result’.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be completed successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, SIG or PLAIN is not a valid pointer, ‘GPG_ERR_NO_DATA’ if SIG
     does not contain any data to verify, and passes through any errors
     that are reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_verify_start (gpgme_ctx_t CTX,
          gpgme_data_t SIG, gpgme_data_t SIGNED_TEXT,
          gpgme_data_t PLAIN)
     The function ‘gpgme_op_verify_start’ initiates a ‘gpgme_op_verify’
     operation.  It can be completed by calling ‘gpgme_wait’ on the
     context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, SIG or PLAIN is not a valid pointer, and ‘GPG_ERR_NO_DATA’ if
     SIG or PLAIN does not contain any data to verify.

 -- Function: gpgme_error_t gpgme_op_verify_ext ( gpgme_ctx_t CTX,
          gpgme_verify_flags_t FLAGS, gpgme_data_t SIG,
          gpgme_data_t SIGNED_TEXT, gpgme_data_t PLAIN)

     The function ‘gpgme_op_verify_ext’ is the same as ‘gpgme_op_verify’
     but has an additional argument FLAGS.  If FLAGS is 0 both function
     behave identically.

     If the flag ‘GPGME_VERIFY_ARCHIVE’ is set, then a signed archive in
     the data object SIG is verified and extracted.  The content of the
     archive is extracted into a directory named ‘GPGARCH_n_’ (where ‘n’
     is a number) or into the directory set with
     ‘gpgme_data_set_file_name’ for the data object PLAIN.

     The value in FLAGS is a bitwise-or combination of one or multiple
     of the following bit values:

     ‘GPGME_VERIFY_ARCHIVE’
          SINCE: 1.19.0

          The ‘GPGME_VERIFY_ARCHIVE’ symbol specifies that the input is
          a signed archive that shall be verified and extracted.  This
          feature is currently only supported for the OpenPGP crypto
          engine and requires GnuPG 2.4.1.

     The function returns the error codes as descriped for
     ‘gpgme_op_decrypt’ respective ‘gpgme_op_encrypt’.

 -- Function: gpgme_error_t gpgme_op_verify_ext_start ( gpgme_ctx_t CTX,
          gpgme_verify_flags_t FLAGS, gpgme_data_t SIG,
          gpgme_data_t SIGNED_TEXT, gpgme_data_t PLAIN)

     The function ‘gpgme_op_verify_ext_start’ initiates a
     ‘gpgme_op_verify_ext’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, SIG or PLAIN is not a valid pointer, and ‘GPG_ERR_NO_DATA’ if
     SIG or PLAIN does not contain any data to verify.

 -- Data type: gpgme_sig_notation_t
     This is a pointer to a structure used to store a part of the result
     of a ‘gpgme_op_verify’ operation.  The structure contains the
     following members:

     ‘gpgme_sig_notation_t next’
          This is a pointer to the next new signature notation structure
          in the linked list, or ‘NULL’ if this is the last element.

     ‘char *name’
          The name of the notation field.  If this is ‘NULL’, then the
          member ‘value’ will contain a policy URL.

     ‘int name_len’
          The length of the ‘name’ field.  For strings the length is
          counted without the trailing binary zero.

     ‘char *value’
          The value of the notation field.  If ‘name’ is ‘NULL’, then
          this is a policy URL.

     ‘int value_len’
          The length of the ‘value’ field.  For strings the length is
          counted without the trailing binary zero.

     ‘gpgme_sig_notation_flags_t flags’
          The accumulated flags field.  This field contains the flags
          associated with the notation data in an accumulated form which
          can be used as an argument to the function
          ‘gpgme_sig_notation_add’.  The value ‘flags’ is a bitwise-or
          combination of one or multiple of the following bit values:

          ‘GPGME_SIG_NOTATION_HUMAN_READABLE’
               SINCE: 1.1.0

               The ‘GPGME_SIG_NOTATION_HUMAN_READABLE’ symbol specifies
               that the notation data is in human readable form

          ‘GPGME_SIG_NOTATION_CRITICAL’
               SINCE: 1.1.0

               The ‘GPGME_SIG_NOTATION_CRITICAL’ symbol specifies that
               the notation data is critical.

     ‘unsigned int human_readable : 1’
          This is true if the ‘GPGME_SIG_NOTATION_HUMAN_READABLE’ flag
          is set and false otherwise.  This flag is only valid for
          notation data, not for policy URLs.

     ‘unsigned int critical : 1’
          This is true if the ‘GPGME_SIG_NOTATION_CRITICAL’ flag is set
          and false otherwise.  This flag is valid for notation data and
          policy URLs.

 -- Data type: gpgme_signature_t
     This is a pointer to a structure used to store a part of the result
     of a ‘gpgme_op_verify’ operation.  The structure contains the
     following members:

     ‘gpgme_signature_t next’
          This is a pointer to the next new signature structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘gpgme_sigsum_t summary’
          This is a bit vector giving a summary of the signature status.
          It provides an easy interface to a defined semantic of the
          signature status.  Checking just one bit is sufficient to see
          whether a signature is valid without any restrictions.  This
          means that you can check for GPGME_SIGSUM_VALID like this:

               if ((sig.summary & GPGME_SIGSUM_VALID))
               {
                  ..do stuff if valid..
               }
               else
               {
                  ..do stuff if not fully valid..
               }

          The defined bits are:
          ‘GPGME_SIGSUM_VALID’
               The signature is fully valid.

          ‘GPGME_SIGSUM_GREEN’
               The signature is good but one might want to display some
               extra information.  Check the other bits.

          ‘GPGME_SIGSUM_RED’
               The signature is bad.  It might be useful to check other
               bits and display more information, i.e., a revoked
               certificate might not render a signature invalid when the
               message was received prior to the cause for the
               revocation.

          ‘GPGME_SIGSUM_KEY_REVOKED’
               The key or at least one certificate has been revoked.

          ‘GPGME_SIGSUM_KEY_EXPIRED’
               The key or one of the certificates has expired.  It is
               probably a good idea to display the date of the
               expiration.

          ‘GPGME_SIGSUM_SIG_EXPIRED’
               The signature has expired.

          ‘GPGME_SIGSUM_KEY_MISSING’
               Can’t verify due to a missing key or certificate.

          ‘GPGME_SIGSUM_CRL_MISSING’
               The CRL (or an equivalent mechanism) is not available.

          ‘GPGME_SIGSUM_CRL_TOO_OLD’
               Available CRL is too old.

          ‘GPGME_SIGSUM_BAD_POLICY’
               A policy requirement was not met.

          ‘GPGME_SIGSUM_SYS_ERROR’
               A system error occurred.

          ‘GPGME_SIGSUM_TOFU_CONFLICT’
               A TOFU conflict was detected.

     ‘char *fpr’
          This is the fingerprint or key ID of the signature.

     ‘gpgme_error_t status’
          This is the status of the signature.  In particular, the
          following status codes are of interest:

          ‘GPG_ERR_NO_ERROR’
               This status indicates that the signature could be
               verified or that there is no signature.  For the combined
               result this status means that all signatures could be
               verified.

               Note: This does not mean that a valid signature could be
               found.  Check the ‘summary’ field for that.

               For example a ‘gpgme_op_decrypt_verify’ returns a
               verification result with GPG_ERR_NO_ERROR for encrypted
               but unsigned data.

          ‘GPG_ERR_SIG_EXPIRED’
               This status indicates that the signature is valid but
               expired.  For the combined result this status means that
               all signatures are valid and expired.

          ‘GPG_ERR_KEY_EXPIRED’
               This status indicates that the signature is valid but the
               key used to verify the signature has expired.  For the
               combined result this status means that all signatures are
               valid and all keys are expired.

          ‘GPG_ERR_CERT_REVOKED’
               This status indicates that the signature is valid but the
               key used to verify the signature has been revoked.  For
               the combined result this status means that all signatures
               are valid and all keys are revoked.

          ‘GPG_ERR_BAD_SIGNATURE’
               This status indicates that the signature is invalid.  For
               the combined result this status means that all signatures
               are invalid.

          ‘GPG_ERR_NO_PUBKEY’
               This status indicates that the signature could not be
               verified due to a missing key.  For the combined result
               this status means that all signatures could not be
               checked due to missing keys.

          ‘GPG_ERR_GENERAL’
               This status indicates that there was some other error
               which prevented the signature verification.

     ‘gpgme_sig_notation_t notations’
          This is a linked list with the notation data and policy URLs.

     ‘unsigned long timestamp’
          The creation timestamp of this signature.

     ‘unsigned long exp_timestamp’
          The expiration timestamp of this signature, or 0 if the
          signature does not expire.

     ‘unsigned int wrong_key_usage : 1’
          This is true if the key was not used according to its policy.

     ‘unsigned int pka_trust : 2’
          This is set to the trust information gained by means of the
          PKA system.  Values are:
          ‘0’
               No PKA information available or verification not
               possible.
          ‘1’
               PKA verification failed.
          ‘2’
               PKA verification succeeded.
          ‘3’
               Reserved for future use.
          Depending on the configuration of the engine, this metric may
          also be reflected by the validity of the signature.

     ‘unsigned int chain_model : 1’
          SINCE: 1.1.6

          This is true if the validity of the signature has been checked
          using the chain model.  In the chain model the time the
          signature has been created must be within the validity period
          of the certificate and the time the certificate itself has
          been created must be within the validity period of the issuing
          certificate.  In contrast the default validation model checks
          the validity of signature as well at the entire certificate
          chain at the current time.

     ‘unsigned int is_de_vs : 1;’
          SINCE: 1.10.0 The signature was created in a VS-NfD compliant
          way.  This is a specification in Germany for a restricted
          communication level.

     ‘unsigned int beta_compliance : 1;’
          SINCE: 1.24.0 The compliance flags (e.g.  is_de_vs) are set
          but the software has not yet been approved or is in a beta
          state.

     ‘gpgme_validity_t validity’
          The validity of the signature.

     ‘gpgme_error_t validity_reason’
          If a signature is not valid, this provides a reason why.

     ‘gpgme_pubkey_algo_t’
          The public key algorithm used to create this signature.

     ‘gpgme_hash_algo_t’
          The hash algorithm used to create this signature.

     ‘char *pka_address’
          The mailbox from the PKA information or ‘NULL’.

     ‘gpgme_key_t key’
          SINCE: 1.7.0

          An object describing the key used to create the signature.
          This key object may be incomplete in that it only conveys
          information availabale directly with a signature.  It may also
          be ‘NULL’ if such information is not readily available.

 -- Data type: gpgme_verify_result_t
     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_verify’ operation.  After verifying a signature, you can
     retrieve the pointer to the result with ‘gpgme_op_verify_result’.
     If the operation failed this might be a ‘NULL’ pointer.  The
     structure contains the following member:

     ‘gpgme_signature_t signatures’
          A linked list with information about all signatures for which
          a verification was attempted.

     ‘char *file_name’
          This is the filename of the original plaintext message file if
          it is known, otherwise this is a null pointer.  Warning: The
          filename is not covered by the signature.

     ‘unsigned int is_mime : 1;’
          SINCE: 1.11.0

          The message claims that the content is a MIME object.
          Warning: This flag is not covered by the signature.

 -- Function: gpgme_verify_result_t gpgme_op_verify_result
          (gpgme_ctx_t CTX)
     The function ‘gpgme_op_verify_result’ returns a
     ‘gpgme_verify_result_t’ pointer to a structure holding the result
     of a ‘gpgme_op_verify’ operation.  The pointer is only valid if the
     last operation on the context was a ‘gpgme_op_verify’,
     ‘gpgme_op_verify_start’, ‘gpgme_op_decrypt_verify’ or
     ‘gpgme_op_decrypt_verify_start’ operation, and if this operation
     finished successfully (for ‘gpgme_op_decrypt_verify’ and
     ‘gpgme_op_decrypt_verify_start’, the error code ‘GPG_ERR_NO_DATA’
     counts as successful in this context).  The returned pointer is
     only valid until the next operation is started on the context.


File: gpgme.info,  Node: Decrypt and Verify,  Next: Sign,  Prev: Verify,  Up: Crypto Operations

7.6.3 Decrypt and Verify
------------------------

 -- Function: gpgme_error_t gpgme_op_decrypt_verify (gpgme_ctx_t CTX,
          gpgme_data_t CIPHER, gpgme_data_t PLAIN)
     The function ‘gpgme_op_decrypt_verify’ decrypts the ciphertext in
     the data object CIPHER and stores it into the data object PLAIN.
     If CIPHER contains signatures, they will be verified.

     After the operation completed, ‘gpgme_op_decrypt_result’ and
     ‘gpgme_op_verify_result’ can be used to retrieve more information
     about the signatures.

     If the error code ‘GPG_ERR_NO_DATA’ is returned, CIPHER does not
     contain any data to decrypt.  However, it might still be signed.
     The information about detected signatures is available with
     ‘gpgme_op_verify_result’ in this case.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     ciphertext could be decrypted successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, CIPHER or PLAIN is not a valid pointer, ‘GPG_ERR_NO_DATA’ if
     CIPHER does not contain any data to decrypt,
     ‘GPG_ERR_DECRYPT_FAILED’ if CIPHER is not a valid cipher text,
     ‘GPG_ERR_BAD_PASSPHRASE’ if the passphrase for the secret key could
     not be retrieved, and passes through any errors that are reported
     by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_decrypt_verify_start
          (gpgme_ctx_t CTX, gpgme_data_t CIPHER, gpgme_data_t PLAIN)
     The function ‘gpgme_op_decrypt_verify_start’ initiates a
     ‘gpgme_op_decrypt_verify’ operation.  It can be completed by
     calling ‘gpgme_wait’ on the context.  *Note Waiting For
     Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, CIPHER, PLAIN or R_STAT is not a valid pointer, and
     ‘GPG_ERR_NO_DATA’ if CIPHER does not contain any data to decrypt.

   When processing mails it is sometimes useful to extract the actual
mail address (the “addr-spec”) from a string.  GPGME provides this
helper function which uses the same semantics as the internal functions
in GPGME and GnuPG:

 -- Function: char * gpgme_addrspec_from_uid (const char *UID)

     SINCE: 1.7.1

     Return the mail address (called “addr-spec” in RFC-5322) from the
     string UID which is assumed to be a user id (called “address” in
     RFC-5322).  All plain ASCII characters (i.e., those with bit 7
     cleared) in the result are converted to lowercase.  Caller must
     free the result using ‘gpgme_free’.  Returns ‘NULL’ if no valid
     address was found (in which case ‘ERRNO’ is set to ‘EINVAL’) or for
     other errors.


File: gpgme.info,  Node: Sign,  Next: Encrypt,  Prev: Decrypt and Verify,  Up: Crypto Operations

7.6.4 Sign
----------

A signature can contain signatures by one or more keys.  The set of keys
used to create a signatures is contained in a context, and is applied to
all following signing operations in this context (until the set is
changed).

* Menu:

* Selecting Signers::             How to choose the keys to sign with.
* Creating a Signature::          How to create a signature.
* Signature Notation Data::       How to add notation data to a signature.


File: gpgme.info,  Node: Selecting Signers,  Next: Creating a Signature,  Up: Sign

7.6.4.1 Selecting Signers
.........................

The key or the keys used to create a signature are stored in the
context.  The following functions can be used to manipulate this list.
If no signer has been set into the context a default key is used for
signing.

 -- Function: void gpgme_signers_clear (gpgme_ctx_t CTX)
     The function ‘gpgme_signers_clear’ releases a reference for each
     key on the signers list and removes the list of signers from the
     context CTX.

     Every context starts with an empty list.

 -- Function: gpgme_error_t gpgme_signers_add (gpgme_ctx_t CTX,
          const gpgme_key_t KEY)
     The function ‘gpgme_signers_add’ adds the key KEY to the list of
     signers in the context CTX.

     Calling this function acquires an additional reference for the key.

 -- Function: unsigned int gpgme_signers_count (const gpgme_ctx_t CTX)
     SINCE: 1.4.3

     The function ‘gpgme_signers_count’ returns the number of signer
     keys in the context CTX.

 -- Function: gpgme_key_t gpgme_signers_enum (const gpgme_ctx_t CTX,
          int SEQ)
     The function ‘gpgme_signers_enum’ returns the SEQth key in the list
     of signers in the context CTX.  An additional reference is acquired
     for the user.

     If SEQ is out of range, ‘NULL’ is returned.


File: gpgme.info,  Node: Creating a Signature,  Next: Signature Notation Data,  Prev: Selecting Signers,  Up: Sign

7.6.4.2 Creating a Signature
............................

 -- Data type: enum gpgme_sig_mode_t
     The ‘gpgme_sig_mode_t’ type is used to specify the desired type of
     a signature.  The following modes are available:

     ‘GPGME_SIG_MODE_NORMAL’
          A normal signature is made, the output includes the plaintext
          and the signature.

     ‘GPGME_SIG_MODE_DETACH’
          A detached signature is made.

     ‘GPGME_SIG_MODE_CLEAR’
          A clear text signature is made.  The ASCII armor and text mode
          settings of the context are ignored.

     ‘GPGME_SIG_MODE_ARCHIVE’
          SINCE: 1.19.0

          A signed archive is created from the given files and
          directories.  This feature is currently only supported for the
          OpenPGP crypto engine and requires GnuPG 2.4.1.

     ‘GPGME_SIG_MODE_FILE’
          SINCE: 1.24.0

          The filename set with ‘gpgme_data_set_file_name’ for the data
          object PLAIN is passed to gpg, so that gpg reads the plaintext
          directly from this file instead of from the data object PLAIN.
          This flag can be combined with ‘GPGME_SIG_MODE_NORMAL’,
          ‘GPGME_SIG_MODE_DETACH’, and ‘GPGME_SIG_MODE_CLEAR’, but not
          with ‘GPGME_SIG_MODE_ARCHIVE’.  This feature is currently only
          supported for the OpenPGP crypto engine.

 -- Function: gpgme_error_t gpgme_op_sign (gpgme_ctx_t CTX,
          gpgme_data_t PLAIN, gpgme_data_t SIG, gpgme_sig_mode_t MODE)
     The function ‘gpgme_op_sign’ creates a signature for the text in
     the data object PLAIN and returns it in the data object SIG or
     writes it directly to the file set with ‘gpgme_data_set_file_name’
     for the data object SIG.  The type of the signature created is
     determined by the ASCII armor (or, if that is not set, by the
     encoding specified for SIG), the text mode attributes set for the
     context CTX and the requested signature mode MODE.

     If the signature mode flag ‘GPGME_SIG_MODE_FILE’ is set and a
     filename has been set with ‘gpgme_data_set_file_name’ for the data
     object PLAIN, then this filename is passed to gpg, so that gpg
     reads the plaintext directly from this file instead of from the
     data object PLAIN.

     If signature mode ‘GPGME_SIG_MODE_ARCHIVE’ is requested then a
     signed archive is created from the files and directories given as
     NUL-separated list in the data object PLAIN.  The paths of the
     files and directories have to be given as paths relative to the
     current working directory or relative to the base directory set
     with ‘gpgme_data_set_file_name’ for the data object PLAIN.

     After the operation completed successfully, the result can be
     retrieved with ‘gpgme_op_sign_result’.

     If an S/MIME signed message is created using the CMS crypto engine,
     the number of certificates to include in the message can be
     specified with ‘gpgme_set_include_certs’.  *Note Included
     Certificates::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     signature could be created successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, PLAIN or SIG is not a valid pointer, ‘GPG_ERR_NO_DATA’ if the
     signature could not be created, ‘GPG_ERR_BAD_PASSPHRASE’ if the
     passphrase for the secret key could not be retrieved,
     ‘GPG_ERR_UNUSABLE_SECKEY’ if there are invalid signers, and passes
     through any errors that are reported by the crypto engine support
     routines.

 -- Function: gpgme_error_t gpgme_op_sign_start (gpgme_ctx_t CTX,
          gpgme_data_t PLAIN, gpgme_data_t SIG, gpgme_sig_mode_t MODE)
     The function ‘gpgme_op_sign_start’ initiates a ‘gpgme_op_sign’
     operation.  It can be completed by calling ‘gpgme_wait’ on the
     context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     CTX, PLAIN or SIG is not a valid pointer.

 -- Data type: gpgme_new_signature_t
     This is a pointer to a structure used to store a part of the result
     of a ‘gpgme_op_sign’ operation.  The structure contains the
     following members:

     ‘gpgme_new_signature_t next’
          This is a pointer to the next new signature structure in the
          linked list, or ‘NULL’ if this is the last element.

     ‘gpgme_sig_mode_t type’
          The type of this signature.

     ‘gpgme_pubkey_algo_t pubkey_algo’
          The public key algorithm used to create this signature.

     ‘gpgme_hash_algo_t hash_algo’
          The hash algorithm used to create this signature.

     ‘unsigned int sig_class’
          The signature class of this signature.  Note that only the
          values 0, 1, and 2 are well-defined.

     ‘long int timestamp’
          The creation timestamp of this signature.

     ‘char *fpr’
          The fingerprint of the key which was used to create this
          signature.

 -- Data type: gpgme_sign_result_t
     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_sign’ operation.  After successfully generating a
     signature, you can retrieve the pointer to the result with
     ‘gpgme_op_sign_result’.  The structure contains the following
     members:

     ‘gpgme_invalid_key_t invalid_signers’
          A linked list with information about all invalid keys for
          which a signature could not be created.

     ‘gpgme_new_signature_t signatures’
          A linked list with information about all signatures created.

 -- Function: gpgme_sign_result_t gpgme_op_sign_result (gpgme_ctx_t CTX)
     The function ‘gpgme_op_sign_result’ returns a ‘gpgme_sign_result_t’
     pointer to a structure holding the result of a ‘gpgme_op_sign’
     operation.  The pointer is only valid if the last operation on the
     context was a ‘gpgme_op_sign’, ‘gpgme_op_sign_start’,
     ‘gpgme_op_encrypt_sign’ or ‘gpgme_op_encrypt_sign_start’ operation.
     If that operation failed, the function might return a ‘NULL’
     pointer.  The returned pointer is only valid until the next
     operation is started on the context.


File: gpgme.info,  Node: Signature Notation Data,  Prev: Creating a Signature,  Up: Sign

7.6.4.3 Signature Notation Data
...............................

Using the following functions, you can attach arbitrary notation data to
a signature.  This information is then available to the user when the
signature is verified.

 -- Function: void gpgme_sig_notation_clear (gpgme_ctx_t CTX)
     SINCE: 1.1.0

     The function ‘gpgme_sig_notation_clear’ removes the notation data
     from the context CTX.  Subsequent signing operations from this
     context will not include any notation data.

     Every context starts with an empty notation data list.

 -- Function: gpgme_error_t gpgme_sig_notation_add (gpgme_ctx_t CTX,
          const char *NAME, const char *VALUE,
          gpgme_sig_notation_flags_t FLAGS)
     SINCE: 1.1.0

     The function ‘gpgme_sig_notation_add’ adds the notation data with
     the name NAME and the value VALUE to the context CTX.

     Subsequent signing operations will include this notation data, as
     well as any other notation data that was added since the creation
     of the context or the last ‘gpgme_sig_notation_clear’ operation.

     The arguments NAME and VALUE must be ‘NUL’-terminated strings in
     human-readable form.  The flag ‘GPGME_SIG_NOTATION_HUMAN_READABLE’
     is implied (non-human-readable notation data is currently not
     supported).  The strings must be in UTF-8 encoding.

     If NAME is ‘NULL’, then VALUE should be a policy URL.

     The function ‘gpgme_sig_notation_add’ returns the error code
     ‘GPG_ERR_NO_ERROR’ if the notation data could be added
     successfully, ‘GPG_ERR_INV_VALUE’ if CTX is not a valid pointer, or
     if NAME, VALUE and FLAGS are an invalid combination.  The function
     also passes through any errors that are reported by the crypto
     engine support routines.

 -- Function: gpgme_sig_notation_t gpgme_sig_notation_get
          (const gpgme_ctx_t CTX)
     SINCE: 1.1.0

     The function ‘gpgme_sig_notation_get’ returns the linked list of
     notation data structures that are contained in the context CTX.

     If CTX is not a valid pointer, or there is no notation data added
     for this context, ‘NULL’ is returned.


File: gpgme.info,  Node: Encrypt,  Prev: Sign,  Up: Crypto Operations

7.6.5 Encrypt
-------------

One plaintext can be encrypted for several recipients at the same time.
The list of recipients is created independently of any context, and then
passed to the encryption operation.

* Menu:

* Encrypting a Plaintext::        How to encrypt a plaintext.


File: gpgme.info,  Node: Encrypting a Plaintext,  Up: Encrypt

7.6.5.1 Encrypting a Plaintext
..............................

 -- Function: gpgme_error_t gpgme_op_encrypt (gpgme_ctx_t CTX,
          gpgme_key_t RECP[], gpgme_encrypt_flags_t FLAGS,
          gpgme_data_t PLAIN, gpgme_data_t CIPHER)
     The function ‘gpgme_op_encrypt’ encrypts the plaintext in the data
     object PLAIN for the recipients RECP and stores the ciphertext in
     the data object CIPHER or writes it directly to the file set with
     ‘gpgme_data_set_file_name’ for the data object CIPHER.  The type of
     the ciphertext created is determined by the ASCII armor (or, if
     that is not set, by the encoding specified for CIPHER) and the text
     mode attributes set for the context CTX.  If a filename has been
     set with ‘gpgme_data_set_file_name’ for the data object PLAIN then
     this filename is stored in the ciphertext.

     If the flag ‘GPGME_ENCRYPT_FILE’ is set and a filename has been set
     with ‘gpgme_data_set_file_name’ for the data object PLAIN, then
     this filename is passed to gpg, so that gpg reads the plaintext
     directly from this file instead of from the data object PLAIN.

     If the flag ‘GPGME_ENCRYPT_ARCHIVE’ is set, then an encrypted
     archive is created from the files and directories given as
     NUL-separated list in the data object PLAIN.  The paths of the
     files and directories have to be given as paths relative to the
     current working directory or relative to the base directory set
     with ‘gpgme_data_set_file_name’ for the data object PLAIN.

     RECP must be a ‘NULL’-terminated array of keys.  The user must keep
     references for all keys during the whole duration of the call (but
     see ‘gpgme_op_encrypt_start’ for the requirements with the
     asynchronous variant).

     The value in FLAGS is a bitwise-or combination of one or multiple
     of the following bit values:

     ‘GPGME_ENCRYPT_ALWAYS_TRUST’
          The ‘GPGME_ENCRYPT_ALWAYS_TRUST’ symbol specifies that all the
          recipients in RECP should be trusted, even if the keys do not
          have a high enough validity in the keyring.  This flag should
          be used with care; in general it is not a good idea to use any
          untrusted keys.

          For the S/MIME (CMS) protocol this flag allows to encrypt to a
          certificate without running any checks on the validity of the
          certificate.

     ‘GPGME_ENCRYPT_NO_ENCRYPT_TO’
          SINCE: 1.2.0

          The ‘GPGME_ENCRYPT_NO_ENCRYPT_TO’ symbol specifies that no
          default or hidden default recipients as configured in the
          crypto backend should be included.  This can be useful for
          managing different user profiles.

     ‘GPGME_ENCRYPT_NO_COMPRESS’
          SINCE: 1.5.0

          The ‘GPGME_ENCRYPT_NO_COMPRESS’ symbol specifies that the
          plaintext shall not be compressed before it is encrypted.
          This is in some cases useful if the length of the encrypted
          message may reveal information about the plaintext.

     ‘GPGME_ENCRYPT_PREPARE’
     ‘GPGME_ENCRYPT_EXPECT_SIGN’
          The ‘GPGME_ENCRYPT_PREPARE’ symbol is used with the UI Server
          protocol to prepare an encryption (i.e., sending the
          ‘PREP_ENCRYPT’ command).  With the ‘GPGME_ENCRYPT_EXPECT_SIGN’
          symbol the UI Server is advised to also expect a sign command.

     ‘GPGME_ENCRYPT_SYMMETRIC’
          SINCE: 1.7.0

          The ‘GPGME_ENCRYPT_SYMMETRIC’ symbol specifies that the output
          should be additionally encrypted symmetrically even if
          recipients are provided.  This feature is only supported for
          the OpenPGP crypto engine.

     ‘GPGME_ENCRYPT_ADD_RECP’
     ‘GPGME_ENCRYPT_CHG_RECP’
          SINCE: 1.24.0

          Instead of encrypting, decrypt the input and write an output
          which is additionally encrypted to the specified keys.  The
          CHG flag is similar but does not add encryption to the
          specified keys but existing encryption keys by the new ones.
          This feature is only supported for the OpenPGP crypto engine
          and requires at least GnuPG version 2.5.1.

     ‘GPGME_ENCRYPT_THROW_KEYIDS’
          SINCE: 1.8.0

          The ‘GPGME_ENCRYPT_THROW_KEYIDS’ symbols requests that the
          identifiers for the decrption keys are not included in the
          ciphertext.  On the receiving side, the use of this flag may
          slow down the decryption process because all available secret
          keys must be tried.  This flag is only honored for OpenPGP
          encryption.

     ‘GPGME_ENCRYPT_WRAP’
          SINCE: 1.8.0

          The ‘GPGME_ENCRYPT_WRAP’ symbol specifies that the input is an
          OpenPGP message and not a plain data.  This is the counterpart
          to ‘GPGME_DECRYPT_UNWRAP’.

     ‘GPGME_ENCRYPT_WANT_ADDRESS’
          SINCE: 1.11.0

          The ‘GPGME_ENCRYPT_WANT_ADDRESS’ symbol requests that all
          supplied keys or key specifications include a syntactically
          valid mail address.  If this is not the case the operation is
          not even tried and the error code ‘GPG_ERR_INV_USER_ID’ is
          returned.  Only the address part of the key specification is
          conveyed to the backend.  As of now the key must be specified
          using the RECPSTRING argument of the extended encrypt
          functions.  This feature is currently only supported for the
          OpenPGP crypto engine.

     ‘GPGME_ENCRYPT_ARCHIVE’
          SINCE: 1.19.0

          The ‘GPGME_ENCRYPT_ARCHIVE’ symbol specifies that the input is
          a NUL-separated list of file paths and directory paths that
          shall be encrypted into an archive.  This feature is currently
          only supported for the OpenPGP crypto engine and requires
          GnuPG 2.4.1.

     ‘GPGME_ENCRYPT_FILE’
          SINCE: 1.24.0

          The ‘GPGME_ENCRYPT_FILE’ symbol specifies that the filename
          set with ‘gpgme_data_set_file_name’ for the data object PLAIN
          is passed to gpg, so that gpg reads the plaintext directly
          from this file instead of from the data object PLAIN.  This
          feature is currently only supported for the OpenPGP crypto
          engine.

     If ‘GPG_ERR_UNUSABLE_PUBKEY’ is returned, some recipients in RECP
     are invalid, but not all.  In this case the plaintext might be
     encrypted for all valid recipients and returned in CIPHER (if this
     happens depends on the crypto engine).  More information about the
     invalid recipients is available with ‘gpgme_op_encrypt_result’.

     If RECP is ‘NULL’, symmetric rather than public key encryption is
     performed.  Symmetrically encrypted cipher text can be deciphered
     with ‘gpgme_op_decrypt’.  Note that in this case the crypto backend
     needs to retrieve a passphrase from the user.  Symmetric encryption
     is currently only supported for the OpenPGP crypto backend.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     ciphertext could be created successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, RECP, PLAIN or CIPHER is not a valid pointer,
     ‘GPG_ERR_UNUSABLE_PUBKEY’ if RECP contains some invalid recipients,
     ‘GPG_ERR_BAD_PASSPHRASE’ if the passphrase for the symmetric key
     could not be retrieved, and passes through any errors that are
     reported by the crypto engine support routines.

 -- Function: gpgme_error_t gpgme_op_encrypt_start (gpgme_ctx_t CTX,
          gpgme_key_t RECP[], gpgme_encrypt_flags_t FLAGS,
          gpgme_data_t PLAIN, gpgme_data_t CIPHER)
     The function ‘gpgme_op_encrypt_start’ initiates a
     ‘gpgme_op_encrypt’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     References to the keys only need to be held for the duration of
     this call.  The user can release its references to the keys after
     this function returns, even if the operation is not yet finished.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, ‘GPG_ERR_INV_VALUE’ if
     CTX, RSET, PLAIN or CIPHER is not a valid pointer, and
     ‘GPG_ERR_UNUSABLE_PUBKEY’ if RSET does not contain any valid
     recipients.

 -- Function: gpgme_error_t gpgme_op_encrypt_ext (gpgme_ctx_t CTX,
          gpgme_key_t RECP[], const char *RECPSTRING,
          gpgme_encrypt_flags_t FLAGS, gpgme_data_t PLAIN,
          gpgme_data_t CIPHER)

     SINCE: 1.11.0

     This is an extended version of ‘gpgme_op_encrypt’ with RECPSTRING
     as additional parameter.  If RECP is NULL and RECPSTRING is not
     NULL, the latter is expected to be a linefeed delimited string with
     the set of key specifications.  In contrast to RECP the keys are
     given directly as strings and there is no need to first create key
     objects.  Leading and trailing white space is remove from each line
     in RECPSTRING.  The keys are then passed verbatim to the backend
     engine.

     For the OpenPGP backend several special keywords are supported to
     modify the operation.  These keywords are given instead of a key
     specification.  The currently supported keywords are:

     ‘--hidden’
     ‘--no-hidden’
          These keywords toggle between normal and hidden recipients for
          all following key specifications.  When a hidden recipient is
          requested the gpg option ‘-R’ (or ‘-F’ in file mode) is used
          instead of ‘-r’ (‘-f’ in file mode).

     ‘--file’
     ‘--no-file’
          These keywords toggle between regular and file mode for all
          following key specification.  In file mode the option ‘-f’ or
          ‘-F’ is passed to gpg.  At least GnuPG version 2.1.14 is
          required to handle these options.  The
          ‘GPGME_ENCRYPT_WANT_ADDRESS’ flag is ignored in file mode.

     ‘--’
          This keyword disables all keyword detection up to the end of
          the string.  All keywords are treated as verbatim arguments.

     To create a RECPSTRING it is often useful to employ a strconcat
     style function.  For example this function creates a string to
     encrypt to two keys:

          char *
          xbuild_recpstring (const char *key1, const char *key2)
          {
            char *result = gpgrt_strconcat ("--\n", key1, "\n", key2, NULL);
            if (!result)
              { perror ("strconcat failed"); exit (2); }
            return result;
          }

     Note the use of the double dash here; unless you want to specify a
     keyword, it is a good idea to avoid any possible trouble with key
     specifications starting with a double dash.  The used strconcat
     function is available in Libgpg-error 1.28 and later; Libgpg-error
     (aka Gpgrt) is a dependency of GPGME. The number of arguments to
     ‘gpgrt_strconcat’ is limited to 47 but that should always be
     sufficient.  In case a larger and non-fixed number of keys are to
     be supplied the following code can be used:

          char *
          xbuild_long_recpstring (void)
          {
            gpgrt_stream_t memfp;
            const char *s;
            void *result;

            memfp = gpgrt_fopenmem (0, "w+b");
            if (!memfp)
              { perror ("fopenmem failed"); exit (2); }
            gpgrt_fputs ("--", memfp);
            while ((s = get_next_keyspec ()))
              {
                gpgrt_fputc ('\n', memfp);
                gpgrt_fputs (s, memfp);
              }
            gpgrt_fputc (0, memfp);
            if (gpgrt_ferror (memfp))
              { perror ("writing to memstream failed"); exit (2); }
            if (gpgrt_fclose_snatch (memfp, &result, NULL))
              { perror ("fclose_snatch failed"); exit (2); }
            return result;
          }

     In this example ‘get_next_keyspec’ is expected to return the next
     key to be added to the string.  Please take care: Encrypting to a
     large number of recipients is often questionable due to security
     reasons and also for the technicality that all keys are currently
     passed on the command line to ‘gpg’ which has as a platform
     specific length limitation.

 -- Function: gpgme_error_t gpgme_op_encrypt_ext_start (gpgme_ctx_t CTX,
          gpgme_key_t RECP[], const char *RECPSTRING,
          gpgme_encrypt_flags_t FLAGS, gpgme_data_t PLAIN,
          gpgme_data_t CIPHER)

     SINCE: 1.11.0

     This is an extended version of ‘gpgme_op_encrypt_start’ with
     RECPSTRING as additional parameter.  If RECP is NULL and RECPSTRING
     is not NULL, the latter is expected to be a linefeed delimited
     string with the set of key specifications.  In contrast to RECP the
     keys are given directly as strings and there is no need to first
     create key objects.  The keys are passed verbatim to the backend
     engine.

 -- Data type: gpgme_encrypt_result_t
     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_encrypt’ operation.  After successfully encrypting data,
     you can retrieve the pointer to the result with
     ‘gpgme_op_encrypt_result’.  The structure contains the following
     members:

     ‘gpgme_invalid_key_t invalid_recipients’
          A linked list with information about all invalid keys for
          which the data could not be encrypted.

 -- Function: gpgme_encrypt_result_t gpgme_op_encrypt_result
          (gpgme_ctx_t CTX)
     The function ‘gpgme_op_encrypt_result’ returns a
     ‘gpgme_encrypt_result_t’ pointer to a structure holding the result
     of a ‘gpgme_op_encrypt’ operation.  The pointer is only valid if
     the last operation on the context was a ‘gpgme_op_encrypt’,
     ‘gpgme_op_encrypt_start’, ‘gpgme_op_sign’ or ‘gpgme_op_sign_start’
     operation.  If this operation failed, this might be a ‘NULL’
     pointer.  The returned pointer is only valid until the next
     operation is started on the context.

 -- Function: gpgme_error_t gpgme_op_encrypt_sign (gpgme_ctx_t CTX,
          gpgme_key_t RECP[], gpgme_encrypt_flags_t FLAGS,
          gpgme_data_t PLAIN, gpgme_data_t CIPHER)
     The function ‘gpgme_op_encrypt_sign’ does a combined encrypt and
     sign operation.  It is used like ‘gpgme_op_encrypt’, but the
     ciphertext also contains signatures for the signers listed in CTX.

     The combined encrypt and sign operation is currently only available
     for the OpenPGP crypto engine.

 -- Function: gpgme_error_t gpgme_op_encrypt_sign_start
          (gpgme_ctx_t CTX, gpgme_key_t RECP[],
          gpgme_encrypt_flags_t FLAGS, gpgme_data_t PLAIN,
          gpgme_data_t CIPHER)
     The function ‘gpgme_op_encrypt_sign_start’ initiates a
     ‘gpgme_op_encrypt_sign’ operation.  It can be completed by calling
     ‘gpgme_wait’ on the context.  *Note Waiting For Completion::.

     The function returns the error code ‘GPG_ERR_NO_ERROR’ if the
     operation could be started successfully, and ‘GPG_ERR_INV_VALUE’ if
     CTX, RSET, PLAIN or CIPHER is not a valid pointer.

 -- Function: gpgme_error_t gpgme_op_encrypt_sign_ext (gpgme_ctx_t CTX,
          gpgme_key_t RECP[], const char *RECPSTRING,
          gpgme_encrypt_flags_t FLAGS, gpgme_data_t PLAIN,
          gpgme_data_t CIPHER)

     SINCE: 1.11.0

     This is an extended version of ‘gpgme_op_encrypt_sign’ with
     RECPSTRING as additional parameter.  If RECP is NULL and RECPSTRING
     is not NULL, the latter is expected to be a linefeed delimited
     string with the set of key specifications.  In contrast to RECP the
     keys are given directly as strings and there is no need to first
     create the key objects.  The keys are passed verbatim to the
     backend engine.

 -- Function: gpgme_error_t gpgme_op_encrypt_sign_ext_start
          (gpgme_ctx_t CTX, gpgme_key_t RECP[], const char *RECPSTRING,
          gpgme_encrypt_flags_t FLAGS, gpgme_data_t PLAIN,
          gpgme_data_t CIPHER)

     SINCE: 1.11.0

     This is an extended version of ‘gpgme_op_encrypt_sign_start’ with
     RECPSTRING as additional parameter.  If RECP is NULL and RECPSTRING
     is not NULL, the latter is expected to be a linefeed delimited
     string with the set of key specifications.  In contrast to RECP the
     keys are given directly as strings and there is no need to first
     create the key objects.  The keys are passed verbatim to the
     backend engine.


File: gpgme.info,  Node: Miscellaneous,  Next: Run Control,  Prev: Crypto Operations,  Up: Contexts

7.7 Miscellaneous operations
============================

Here are some support functions which are sometimes useful.

* Menu:

* Running other Programs::      Running other Programs
* Using the Assuan protocol::   Using the Assuan protocol
* Checking for updates::        How to check for software updates


File: gpgme.info,  Node: Running other Programs,  Next: Using the Assuan protocol,  Up: Miscellaneous

7.7.1 Running other Programs
----------------------------

GPGME features an internal subsystem to run the actual backend engines.
Along with data abstraction object this subsystem can be used to run
arbitrary simple programs which even need not be related to
cryptographic features.  It may for example be used to run tools which
are part of the GnuPG system but are not directly accessible with the
GPGME API.

 -- Function: gpgme_error_t gpgme_op_spawn (gpgme_ctx_t CTX,
          const char *FILE, const char *ARGV[], gpgme_data_t DATAIN,
          gpgme_data_t DATAOUT, gpgme_data_t DATAERR,
          unsigned int FLAGS)

     SINCE: 1.5.0

     The function ‘gpgme_op_spawn’ runs the program FILE with the
     arguments taken from the NULL terminated array ARGV.  If no
     arguments are required ARGV may be given as ‘NULL’.  In the latter
     case or if ‘argv[0]’ is the empty string, GPGME uses the basename
     of FILE for ‘argv[0]’.  The file descriptors ‘stdin’, ‘stdout’, and
     ‘stderr’ are connected to the data objects DATAIN, DATAOUT, and
     DATAERR.  If NULL is passed for one of these data objects the
     corresponding file descriptor is connected to ‘/dev/null’.

     The value in FLAGS is a bitwise-or combination of one or multiple
     of the following bit values:

     ‘GPGME_SPAWN_DETACHED’
          SINCE: 1.5.0

          Under Windows this flag inhibits the allocation of a new
          console for the program.  This is useful for a GUI application
          which needs to call a command line helper tool.

     ‘GPGME_SPAWN_ALLOW_SET_FG’
          SINCE: 1.5.0

          Under Windows this flag allows the called program to put
          itself into the foreground.

 -- Function: gpgme_error_t gpgme_op_spawn_start (gpgme_ctx_t CTX,
          const char *FILE, const char *ARGV[], gpgme_data_t DATAIN,
          gpgme_data_t DATAOUT, gpgme_data_t DATAERR,
          unsigned int FLAGS)

     SINCE: 1.5.0

     This is the asynchronous variant of ‘gpgme_op_spawn’.


File: gpgme.info,  Node: Using the Assuan protocol,  Next: Checking for updates,  Prev: Running other Programs,  Up: Miscellaneous

7.7.2 Using the Assuan protocol
-------------------------------

The Assuan protocol can be used to talk to arbitrary Assuan servers.  By
default it is connected to the GnuPG agent, but it may be connected to
arbitrary servers by using ‘gpgme_ctx_set_engine_info’, passing the
location of the servers socket as FILE_NAME argument, and an empty
string as HOME_DIR argument.

   The Assuan protocol functions use three kinds of callbacks to
transfer data:

 -- Data type: gpgme_error_t (*gpgme_assuan_data_cb_t) (void *OPAQUE,
          const void *DATA, size_t DATALEN)

     SINCE: 1.2.0

     This callback receives any data sent by the server.  OPAQUE is the
     pointer passed to ‘gpgme_op_assuan_transact_start’, DATA of length
     DATALEN refers to the data sent.

 -- Data type: gpgme_error_t (*gpgme_assuan_inquire_cb_t) (void *OPAQUE,
          const char *NAME, const char *ARGS, gpgme_data_t *R_DATA)

     SINCE: 1.2.0

     This callback is used to provide additional data to the Assuan
     server.  OPAQUE is the pointer passed to
     ‘gpgme_op_assuan_transact_start’, NAME and ARGS specify what kind
     of data the server requested, and R_DATA is used to return the
     actual data.

     Note: Returning data is currently not implemented in GPGME.

 -- Data type: gpgme_error_t (*gpgme_assuan_status_cb_t) (void *OPAQUE,
          const char *STATUS, const char *ARGS)

     SINCE: 1.2.0

     This callback receives any status lines sent by the server.  OPAQUE
     is the pointer passed to ‘gpgme_op_assuan_transact_start’, STATUS
     and ARGS denote the status update sent.

 -- Function: gpgme_error_t gpgme_op_assuan_transact_start
          (gpgme_ctx_t CTX, const char *COMMAND,
          gpgme_assuan_data_cb_t DATA_CB, void * DATA_CB_VALUE,
          gpgme_assuan_inquire_cb_t INQUIRE_CB, void * INQUIRE_CB_VALUE,
          gpgme_assuan_status_cb_t STATUS_CB, void * STATUS_CB_VALUE)

     SINCE: 1.2.0

     Send the Assuan COMMAND and return results via the callbacks.  Any
     callback may be ‘NULL’.  The result of the operation may be
     retrieved using ‘gpgme_wait_ext’.

     Asynchronous variant.

 -- Function: gpgme_error_t gpgme_op_assuan_transact_ext
          (gpgme_ctx_t CTX, const char *COMMAND,
          gpgme_assuan_data_cb_t DATA_CB, void * DATA_CB_VALUE,
          gpgme_assuan_inquire_cb_t INQUIRE_CB, void * INQUIRE_CB_VALUE,
          gpgme_assuan_status_cb_t STATUS_CB, void * STATUS_CB_VALUE,
          gpgme_error_t *OP_ERR)

     Send the Assuan COMMAND and return results via the callbacks.  The
     result of the operation is returned in OP_ERR.

     Synchronous variant.


File: gpgme.info,  Node: Checking for updates,  Prev: Using the Assuan protocol,  Up: Miscellaneous

7.7.3 How to check for software updates
---------------------------------------

The GnuPG Project operates a server to query the current versions of
software packages related to GnuPG. GPGME can be used to access this
online database and check whether a new version of a software package is
available.

 -- Data type: gpgme_query_swdb_result_t
     SINCE: 1.8.0

     This is a pointer to a structure used to store the result of a
     ‘gpgme_op_query_swdb’ operation.  After success full call to that
     function, you can retrieve the pointer to the result with
     ‘gpgme_op_query_swdb_result’.  The structure contains the following
     member:

     ‘name’
          This is the name of the package.

     ‘iversion’
          The currently installed version or an empty string.  This
          value is either a copy of the argument given to
          ‘gpgme_op_query_swdb’ or the version of the installed software
          as figured out by GPGME or GnuPG.

     ‘created’
          This gives the date the file with the list of version numbers
          has originally be created by the GnuPG project.

     ‘retrieved’
          This gives the date the file was downloaded.

     ‘warning’
          If this flag is set either an error has occurred or some of
          the information in this structure are not properly set.  For
          example if the version number of the installed software could
          not be figured out, the ‘update’ flag may not reflect a
          required update status.

     ‘update’
          If this flag is set an update of the software is available.

     ‘urgent’
          If this flag is set an available update is important.

     ‘noinfo’
          If this flag is set, no valid information could be retrieved.

     ‘unknown’
          If this flag is set the given ‘name’ is not known.

     ‘tooold’
          If this flag is set the available information is not fresh
          enough.

     ‘error’
          If this flag is set some other error has occurred.

     ‘version’
          The version string of the latest released version.

     ‘reldate’
          The release date of the latest released version.

 -- Function: gpgme_error_t gpgme_op_query_swdb (gpgme_ctx_t CTX,
          const char *NAME, const char *IVERSION, gpgme_data_t RESERVED)

     SINCE: 1.8.0

     Query the software version database for software package NAME and
     check against the installed version given by IVERSION.  If IVERSION
     is given as ‘NULL’ a check is only done if GPGME can figure out the
     version by itself (for example when using "gpgme" or "gnupg").  If
     ‘NULL’ is used for NAME the current gpgme version is checked.
     RESERVED must be set to 0.

 -- Function: gpgme_query_swdb_result_t gpgme_op_query_swdb_result
          (gpgme_ctx_t CTX)

     SINCE: 1.8.0

     The function ‘gpgme_op_query_swdb_result’ returns a
     ‘gpgme_query_swdb_result_t’ pointer to a structure holding the
     result of a ‘gpgme_op_query_swdb’ operation.  The pointer is only
     valid if the last operation on the context was a successful call to
     ‘gpgme_op_query_swdb’.  If that call failed, the result might be a
     ‘NULL’ pointer.  The returned pointer is only valid until the next
     operation is started on the context CTX.

Here is an example on how to check whether GnuPG is current:

     #include <gpgme.h>

     int
     main (void)
     {
       gpg_error_t err;
       gpgme_ctx_t ctx;
       gpgme_query_swdb_result_t result;

       gpgme_check_version (NULL);
       err = gpgme_new (&ctx);
       if (err)
         fprintf (stderr, "error creating context: %s\n", gpg_strerror (err));
       else
         {
           gpgme_set_protocol (ctx, GPGME_PROTOCOL_GPGCONF);

           err = gpgme_op_query_swdb (ctx, "gnupg", NULL, 0);
           if (err)
             fprintf (stderr, "error querying swdb: %s\n", gpg_strerror (err));
           else
             {
               result = gpgme_op_query_swdb_result (ctx);
               if (!result)
                 fprintf (stderr, "error querying swdb\n");
               if (!result->warning && !result->update)
                 printf ("GnuPG version %s is current\n",
                         result->iversion);
               else if (!result->warning && result->update)
                 printf ("GnuPG version %s can be updated to %s\n",
                         result->iversion, result->version);
               else
                 fprintf (stderr, "error finding the update status\n");
             }
           gpgme_release (ctx);
         }
       return 0;
     }


File: gpgme.info,  Node: Run Control,  Prev: Miscellaneous,  Up: Contexts

7.8 Run Control
===============

GPGME supports running operations synchronously and asynchronously.  You
can use asynchronous operation to set up a context up to initiating the
desired operation, but delay performing it to a later point.

   Furthermore, you can use an external event loop to control exactly
when GPGME runs.  This ensures that GPGME only runs when necessary and
also prevents it from blocking for a long time.

* Menu:

* Waiting For Completion::        Waiting until an operation is completed.
* Using External Event Loops::    Advanced control over what happens when.
* Cancellation::                  How to end pending operations prematurely.


File: gpgme.info,  Node: Waiting For Completion,  Next: Using External Event Loops,  Up: Run Control

7.8.1 Waiting For Completion
----------------------------

 -- Function: gpgme_ctx_t gpgme_wait (gpgme_ctx_t CTX,
          gpgme_error_t *STATUS, int HANG)
     The function ‘gpgme_wait’ continues the pending operation within
     the context CTX.  In particular, it ensures the data exchange
     between GPGME and the crypto backend and watches over the run time
     status of the backend process.

     If HANG is true, the function does not return until the operation
     is completed or cancelled.  Otherwise the function will not block
     for a long time.

     The error status of the finished operation is returned in STATUS if
     ‘gpgme_wait’ does not return ‘NULL’.

     The CTX argument can be ‘NULL’.  In that case, ‘gpgme_wait’ waits
     for any context to complete its operation.

     ‘gpgme_wait’ can be used only in conjunction with any context that
     has a pending operation initiated with one of the
     ‘gpgme_op_*_start’ functions except ‘gpgme_op_keylist_start’ and
     ‘gpgme_op_trustlist_start’ (for which you should use the
     corresponding ‘gpgme_op_*_next’ functions).  If CTX is ‘NULL’, all
     of such contexts are waited upon and possibly returned.
     Synchronous operations running in parallel, as well as key and
     trust item list operations, do not affect ‘gpgme_wait’.

     In a multi-threaded environment, only one thread should ever call
     ‘gpgme_wait’ at any time, regardless of whether CTX is specified or
     not.  This means that all calls to this function should be fully
     synchronized by locking primitives.  It is safe to start
     asynchronous operations while a thread is running in ‘gpgme_wait’.

     The function returns the CTX of the context which has finished the
     operation.  If HANG is false, and the timeout expires, ‘NULL’ is
     returned and ‘*status’ will be set to 0.  If an error occurs,
     ‘NULL’ is returned and the error is returned in ‘*status’.


File: gpgme.info,  Node: Using External Event Loops,  Next: Cancellation,  Prev: Waiting For Completion,  Up: Run Control

7.8.2 Using External Event Loops
--------------------------------

GPGME hides the complexity of the communication between the library and
the crypto engine.  The price of this convenience is that the calling
thread can block arbitrary long waiting for the data returned by the
crypto engine.  In single-threaded programs, in particular if they are
interactive, this is an unwanted side-effect.  OTOH, if ‘gpgme_wait’ is
used without the HANG option being enabled, it might be called
unnecessarily often, wasting CPU time that could be used otherwise.

   The I/O callback interface described in this section lets the user
take control over what happens when.  GPGME will provide the user with
the file descriptors that should be monitored, and the callback
functions that should be invoked when a file descriptor is ready for
reading or writing.  It is then the user’s responsibility to decide when
to check the file descriptors and when to invoke the callback functions.
Usually this is done in an event loop, that also checks for events in
other parts of the program.  If the callback functions are only called
when the file descriptors are ready, GPGME will never block.  This gives
the user more control over the program flow, and allows to perform other
tasks when GPGME would block otherwise.

   By using this advanced mechanism, GPGME can be integrated smoothly
into GUI toolkits like GTK+ even for single-threaded programs.

* Menu:

* I/O Callback Interface::        How I/O callbacks are registered.
* Registering I/O Callbacks::     How to use I/O callbacks for a context.
* I/O Callback Example::          An example how to use I/O callbacks.
* I/O Callback Example GTK+::     How to use GPGME with GTK+.
* I/O Callback Example GDK::      How to use GPGME with GDK.
* I/O Callback Example Qt::       How to use GPGME with Qt.


File: gpgme.info,  Node: I/O Callback Interface,  Next: Registering I/O Callbacks,  Up: Using External Event Loops

7.8.2.1 I/O Callback Interface
..............................

 -- Data type: gpgme_error_t (*gpgme_io_cb_t) (void *DATA, int FD)
     The ‘gpgme_io_cb_t’ type is the type of functions which GPGME wants
     to register as I/O callback handlers using the
     ‘gpgme_register_io_cb_t’ functions provided by the user.

     DATA and FD are provided by GPGME when the I/O callback handler is
     registered, and should be passed through to the handler when it is
     invoked by the user because it noticed activity on the file
     descriptor FD.

     The callback handler always returns ‘0’, but you should consider
     the return value to be reserved for later use.

 -- Data type: gpgme_error_t (*gpgme_register_io_cb_t) (void *DATA,
          int FD, int DIR, gpgme_io_cb_t FNC, void *FNC_DATA,
          void **TAG)
     The ‘gpgme_register_io_cb_t’ type is the type of functions which
     can be called by GPGME to register an I/O callback function FNC for
     the file descriptor FD with the user.  FNC_DATA should be passed as
     the first argument to FNC when the handler is invoked (the second
     argument should be FD).  If DIR is 0, FNC should be called by the
     user when FD is ready for writing.  If DIR is 1, FNC should be
     called when FD is ready for reading.

     DATA was provided by the user when registering the
     ‘gpgme_register_io_cb_t’ function with GPGME and will always be
     passed as the first argument when registering a callback function.
     For example, the user can use this to determine the event loop to
     which the file descriptor should be added.

     GPGME will call this function when a crypto operation is initiated
     in a context for which the user has registered I/O callback handler
     functions with ‘gpgme_set_io_cbs’.  It can also call this function
     when it is in an I/O callback handler for a file descriptor
     associated to this context.

     The user should return a unique handle in TAG identifying this I/O
     callback registration, which will be passed to the
     ‘gpgme_register_io_cb_t’ function without interpretation when the
     file descriptor should not be monitored anymore.

 -- Data type: void (*gpgme_remove_io_cb_t) (void *TAG)
     The ‘gpgme_remove_io_cb_t’ type is the type of functions which can
     be called by GPGME to remove an I/O callback handler that was
     registered before.  TAG is the handle that was returned by the
     ‘gpgme_register_io_cb_t’ for this I/O callback.

     GPGME can call this function when a crypto operation is in an I/O
     callback.  It will also call this function when the context is
     destroyed while an operation is pending.

 -- Data type: enum gpgme_event_io_t
     The ‘gpgme_event_io_t’ type specifies the type of an event that is
     reported to the user by GPGME as a consequence of an I/O operation.
     The following events are defined:

     ‘GPGME_EVENT_START’
          The operation is fully initialized now, and you can start to
          run the registered I/O callback handlers now.  Note that
          registered I/O callback handlers must not be run before this
          event is signalled.  TYPE_DATA is ‘NULL’ and reserved for
          later use.

     ‘GPGME_EVENT_DONE’
          The operation is finished, the last I/O callback for this
          operation was removed.  The accompanying TYPE_DATA points to a
          ‘struct gpgme_io_event_done_data’ variable that contains the
          status of the operation that finished.  This event is
          signalled after the last I/O callback has been removed.

     ‘GPGME_EVENT_NEXT_KEY’
          In a ‘gpgme_op_keylist_start’ operation, the next key was
          received from the crypto engine.  The accompanying TYPE_DATA
          is a ‘gpgme_key_t’ variable that contains the key with one
          reference for the user.

 -- Data type: void (*gpgme_event_io_cb_t) (void *DATA,
          gpgme_event_io_t TYPE, void *TYPE_DATA)
     The ‘gpgme_event_io_cb_t’ type is the type of functions which can
     be called by GPGME to signal an event for an operation running in a
     context which has I/O callback functions registered by the user.

     DATA was provided by the user when registering the
     ‘gpgme_event_io_cb_t’ function with GPGME and will always be passed
     as the first argument when registering a callback function.  For
     example, the user can use this to determine the context in which
     this event has occurred.

     TYPE will specify the type of event that has occurred.  TYPE_DATA
     specifies the event further, as described in the above list of
     possible ‘gpgme_event_io_t’ types.

     GPGME can call this function in an I/O callback handler.


File: gpgme.info,  Node: Registering I/O Callbacks,  Next: I/O Callback Example,  Prev: I/O Callback Interface,  Up: Using External Event Loops

7.8.2.2 Registering I/O Callbacks
.................................

 -- Data type: struct gpgme_io_cbs
     This structure is used to store the I/O callback interface
     functions described in the previous section.  It has the following
     members:

     ‘gpgme_register_io_cb_t add’
          This is the function called by GPGME to register an I/O
          callback handler.  It must be specified.

     ‘void *add_priv’
          This is passed as the first argument to the ‘add’ function
          when it is called by GPGME.  For example, it can be used to
          determine the event loop to which the file descriptor should
          be added.

     ‘gpgme_remove_io_cb_t remove’
          This is the function called by GPGME to remove an I/O callback
          handler.  It must be specified.

     ‘gpgme_event_io_cb_t event’
          This is the function called by GPGME to signal an event for an
          operation.  It must be specified, because at least the start
          event must be processed.

     ‘void *event_priv’
          This is passed as the first argument to the ‘event’ function
          when it is called by GPGME.  For example, it can be used to
          determine the context in which the event has occurred.

 -- Function: void gpgme_set_io_cbs (gpgme_ctx_t CTX,
          struct gpgme_io_cbs *IO_CBS)
     The function ‘gpgme_set_io_cbs’ enables the I/O callback interface
     for the context CTX.  The I/O callback functions are specified by
     IO_CBS.

     If IO_CBS->‘add’ is ‘NULL’, the I/O callback interface is disabled
     for the context, and normal operation is restored.

 -- Function: void gpgme_get_io_cbs (gpgme_ctx_t CTX,
          struct gpgme_io_cbs *IO_CBS)
     The function ‘gpgme_get_io_cbs’ returns the I/O callback functions
     set with ‘gpgme_set_io_cbs’ in IO_CBS.


File: gpgme.info,  Node: I/O Callback Example,  Next: I/O Callback Example GTK+,  Prev: Registering I/O Callbacks,  Up: Using External Event Loops

7.8.2.3 I/O Callback Example
............................

To actually use an external event loop, you have to implement the I/O
callback functions that are used by GPGME to register and unregister
file descriptors.  Furthermore, you have to actually monitor these file
descriptors for activity and call the appropriate I/O callbacks.

   The following example illustrates how to do that.  The example uses
locking to show in which way the callbacks and the event loop can run
concurrently.  For the event loop, we use a fixed array.  For a
real-world implementation, you should use a dynamically sized structure
because the number of file descriptors needed for a crypto operation in
GPGME is not predictable.

     #include <assert.h>
     #include <errno.h>
     #include <stdlib.h>
     #include <pthread.h>
     #include <sys/types.h>
     #include <gpgme.h>

     /* The following structure holds the result of a crypto operation.  */
     struct op_result
     {
       int done;
       gpgme_error_t err;
     };

     /* The following structure holds the data associated with one I/O
     callback.  */
     struct one_fd
     {
       int fd;
       int dir;
       gpgme_io_cb_t fnc;
       void *fnc_data;
       void *loop;
     };

     struct event_loop
     {
       pthread_mutex_t lock;
     #define MAX_FDS 32
       /* Unused slots are marked with FD being -1.  */
       struct one_fd fds[MAX_FDS];
     };

   The following functions implement the I/O callback interface.

     gpgme_error_t
     add_io_cb (void *data, int fd, int dir, gpgme_io_cb_t fnc, void *fnc_data,
     	   void **r_tag)
     {
       struct event_loop *loop = data;
       struct one_fd *fds = loop->fds;
       int i;

       pthread_mutex_lock (&loop->lock);
       for (i = 0; i < MAX_FDS; i++)
         {
           if (fds[i].fd == -1)
     	{
     	  fds[i].fd = fd;
     	  fds[i].dir = dir;
     	  fds[i].fnc = fnc;
     	  fds[i].fnc_data = fnc_data;
     	  fds[i].loop = loop;
     	  break;
     	}
         }
       pthread_mutex_unlock (&loop->lock);
       if (i == MAX_FDS)
         return gpg_error (GPG_ERR_GENERAL);
       *r_tag = &fds[i];
       return 0;
     }

     void
     remove_io_cb (void *tag)
     {
       struct one_fd *fd = tag;
       struct event_loop *loop = fd->loop;

       pthread_mutex_lock (&loop->lock);
       fd->fd = -1;
       pthread_mutex_unlock (&loop->lock);
     }

     void
     event_io_cb (void *data, gpgme_event_io_t type, void *type_data)
     {
       struct op_result *result = data;

       /* We don't support list operations here.  */
       if (type == GPGME_EVENT_DONE)
         {
           result->done = 1;
           result->err = *type_data;
         }
     }

   The final missing piece is the event loop, which will be presented
next.  We only support waiting for the success of a single operation.

     int
     do_select (struct event_loop *loop)
     {
       fd_set rfds;
       fd_set wfds;
       int i, n;
       int any = 0;
       struct timeval tv;
       struct one_fd *fdlist = loop->fds;

       pthread_mutex_lock (&loop->lock);
       FD_ZERO (&rfds);
       FD_ZERO (&wfds);
       for (i = 0; i < MAX_FDS; i++)
         if (fdlist[i].fd != -1)
           FD_SET (fdlist[i].fd, fdlist[i].dir ? &rfds : &wfds);
       pthread_mutex_unlock (&loop->lock);

       tv.tv_sec = 0;
       tv.tv_usec = 1000;

       do
         {
           n = select (FD_SETSIZE, &rfds, &wfds, NULL, &tv);
         }
       while (n < 0 && errno == EINTR);

       if (n < 0)
         return n;	/* Error or timeout.  */

       pthread_mutex_lock (&loop->lock);
       for (i = 0; i < MAX_FDS && n; i++)
         {
           if (fdlist[i].fd != -1)
     	{
     	  if (FD_ISSET (fdlist[i].fd, fdlist[i].dir ? &rfds : &wfds))
     	    {
     	      assert (n);
     	      n--;
     	      any = 1;
                   /* The I/O callback handler can register/remove callbacks,
                      so we have to unlock the file descriptor list.  */
                   pthread_mutex_unlock (&loop->lock);
     	      (*fdlist[i].fnc) (fdlist[i].fnc_data, fdlist[i].fd);
                   pthread_mutex_lock (&loop->lock);
     	    }
     	}
         }
       pthread_mutex_unlock (&loop->lock);
       return any;
     }

     void
     wait_for_op (struct event_loop *loop, struct op_result *result)
     {
       int ret;

       do
         {
           ret = do_select (loop);
         }
       while (ret >= 0 && !result->done);
     }

   The main function shows how to put it all together.

     int
     main (int argc, char *argv[])
     {
       struct event_loop loop;
       struct op_result result;
       gpgme_ctx_t ctx;
       gpgme_error_t err;
       gpgme_data_t sig, text;
       int i;
       pthread_mutexattr_t attr;
       struct gpgme_io_cbs io_cbs =
       {
         add_io_cb,
         &loop,
         remove_io_cb,
         event_io_cb,
         &result
       };

       init_gpgme ();

       /* Initialize the loop structure.  */

       /* The mutex must be recursive, since remove_io_cb (which acquires a
          lock) can be called while holding a lock acquired in do_select.  */
       pthread_mutexattr_init (&attr);
       pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
       pthread_mutex_init (&loop.lock, &attr);
       pthread_mutexattr_destroy (&attr);

       for (i = 0; i < MAX_FDS; i++)
         loop.fds[i].fd = -1;

       /* Initialize the result structure.  */
       result.done = 0;

       err = gpgme_data_new_from_file (&sig, "signature", 1);
       if (!err)
         err = gpgme_data_new_from_file (&text, "text", 1);
       if (!err)
         err = gpgme_new (&ctx);
       if (!err)
         {
            gpgme_set_io_cbs (ctx, &io_cbs);
            err = gpgme_op_verify_start (ctx, sig, text, NULL);
         }
       if (err)
         {
           fprintf (stderr, "gpgme error: %s: %s\n",
                    gpgme_strsource (err), gpgme_strerror (err));
           exit (1);
         }

       wait_for_op (&loop, &result);
       if (!result.done)
         {
           fprintf (stderr, "select error\n");
           exit (1);
         }
       if (!result.err)
         {
           fprintf (stderr, "verification failed: %s: %s\n",
                    gpgme_strsource (result.err), gpgme_strerror (result.err));
           exit (1);
         }
       /* Evaluate verify result.  */
       ...
       return 0;
     }

